<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Vanillacrypto</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script>
// Iteration count for PBKDF2. At least 10000. The higher the value
// the longer you'll need to wait after entering the password to
// derive the key used for encryption.
const PBKDF2_ITERATIONS = new URLSearchParams(document.location.search).get('iterations')
      || 60000;
// Url fo the service (an instance of Piggy Store) where you could optionally
// store your encrypted data
const STORE_URL = 'http://localhost:5000';
// Url (prefix) that you can trust to upload files to. Make sure it ends with /
// to not accept malicious urls (like foo.comicly.broken instead of foo.com)
const TRUSTED_UPLOAD_BASE_URL = new URLSearchParams(document.location.search).get('upload_base_url')
      || 'http://localhost:9000/';
const ERRORS_QUEUE = [];
</script>
<style>

:root {
  --main-bg-color: #32393F;
  --main-fg-color: rgb(194, 196, 198);
  --secondary-bg-color: #033649;
  --highlight-color: #696969;
  --secondary-fg-color: #CDB380;
  --warning-color: #ffcc00;
  --error-color: #cc3300;
  --font-default: Verdana, Geneva, Tahoma, sans-serif;
  --font-mono: Andale Mono, AndaleMono, Consolas, Monaco, monospace;
  --font-textarea: "Helvetica Neue",Helvetica,Arial,sans-serif;
}

html {
    background-color: var(--main-bg-color);
    color: var(--main-fg-color);
    font-family: var(--font-default);
    height: 100%;
}

body {
    box-sizing: border-box;
    max-width: 1200px;
    width: 100%;
    padding: 1em;
    margin: 0 auto;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    min-height: 100%;
}

p {
    margin: 0;
}

.main-container {
    display: flex;
    width: 100%;
    flex: 1 0 auto;
    flex-wrap: wrap;
}

label {
    cursor: pointer;
}

textarea, button {
    box-sizing: border-box;
}

.plaintext-container, .ciphertext-container {
    box-sizing: border-box;
    padding: 0 1em;
    display: flex;
    flex: 1 1 50%;
    flex-direction: column;
    min-width: 360px;
    margin-top: 1em;
}

#ciphertext {
    font-family: var(--font-mono);
}

#ciphertext-error-bar {
    color: var(--warning-color);
}

span.error:empty:before {
    content: "\200b"; /* unicode zero width space character */
}

#download-cleartext {
    color: var(--error-color);
}

button {
    font-weight:bold;
    cursor: pointer;
}

textarea {
  flex: 1 1 100%;
  min-height: 70vh; /* effective on narrow windows when textareas reflow */
  background: none repeat scroll 0 0 rgba(0, 0, 0, 0.07);
  border-radius: 6px;
  border-style: none solid solid none;
  border-width: medium 1px 1px medium;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.12) inset;
  color: var(--main-fg-color);
  font-family: var(--font-textarea);
  font-size: 1em;
  line-height: 1.4em;
  padding: 0.5em;
  transition: background-color 0.2s ease 0s;
}

textarea:focus {
    background: none repeat scroll 0 0 var(--main-fg-color);
    color: var(--main-bg-color);
    outline-width: 0;
}

textarea::placeholder {
    font-weight: bold;
    color: var(--main-fg-color);
    opacity: 1;
    font-family: var(--font-textarea);
}

textarea:focus::placeholder {
    color: transparent;
}

#login-form {
    display: none;
    flex-direction: column;
    align-items: center;
    width: 300px;
}

.login-text {
    margin: 0.5em 0 2em 0;
    width: 90%;
}

.require-login .main-container,
.require-login #logout-btn,
.external.action,
#overlay.is-hidden {
    display: none;
}

.require-login #login-form {
    display: flex;
}

.enable-external-actions .external.action {
    display: initial;
}

.actions {
    text-align: right;
}

.action-bar {
    width: 100%;
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    flex-wrap: wrap;
    margin-bottom: 0.5em;
}

button.action {
    margin-bottom: 0.2em;
}

.action-bar .title {
    font-weight: bold;
    color: #af9f88;
    text-shadow: 0 0 33px black;
    font-size: 1.3em;
    margin: 0 0.2em 0.2em 0;
}

#error-bar {
    line-height: 1.5em;
    background-color: var(--error-color);
    color: black;
    text-align: center;
    position: fixed;
    top: 0;
    width: 100%;
    cursor: pointer;
}

#error-bar:not(:empty)::after {
    content: "x";
    position: absolute;
    right: 0.5em;
    font-family: var(--font-mono);
    font-weight: bold;
}

@keyframes bounce {
    0%, 20%, 53%, 80%, 100% {
        transition-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
        transform: translate3d(0,0,0);
    }
    40%, 43% {
        transition-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
        transform: translate3d(0, 30px, 0);
    }
    70% {
        transition-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
        transform: translate3d(0, 15px, 0);
    }
    90% {
        transform: translate3d(0,4px,0);
    }
}

.bump {
    animation: bounce 1s ;
    transform-origin: center bottom;
}

.no-bump {
    animation: bounce 1s;
    transform-origin: center bottom;
    animation-direction: reverse;
}

#overlay {
    display: flex;
    background-color: rgba(159, 159, 187, 0.56);
    position: fixed;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    justify-content: center;
    align-items: center;
}

@keyframes spinner-animation {
  to {transform: rotate(360deg);}
}

#spinner {
  box-sizing: border-box;
  width: 4em;
  height: 4em;
  border-radius: 50%;
  border: 2px solid #ccc;
  border-top-color: #333;
  animation: spinner-animation .6s linear infinite;
}


</style>
</head>
<body spellcheck="false" class="require-login enable-external-actions" onload="onPageLoaded()">

<form id="login-form" class="page-load">
    <label class="login-label" for="username">Username (optional)</label>
    <input id="username" type="text"
        title="You can omit the username, but then you won't be able to access external services (e.g. to upload/sync your files)"
        class="login-text"
        autocomplete="off" />
    <label class="login-label" for="secret">Password</label>
    <input id="secret" type="password"
        class="login-text"
        required=""
        autocomplete="new-password" />
    <label class="login-label" for="confirm-secret">Confirm Password</label>
    <input id="confirm-secret" type="password"
        class="login-text"
        required=""
        autocomplete="new-password" />
    <button id="login-btn" type="submit" disabled="disabled" autocomplete="off">Unlock</button>
</form>

<button id="logout-btn">Logout</button>

<main class="main-container">

<div class="plaintext-container">
    <p class="action-bar"><label class="title" for="plaintext">Cleartext</label> <button id="download-cleartext" class="action">⬇ download</button></p>
    <textarea id="plaintext" class="change-ciphertext" autocomplete="off" placeholder="Click here to type some text to encrypt"></textarea>
</div>

<div class="ciphertext-container">
    <p class="action-bar">
    <label class="title" for="ciphertext">Ciphertext</label>
    <span class="actions">
    <button id="reload-ciphertext" class="external action">⟳ reload</button>
    <button id="upload-ciphertext" class="external action">⬆ upload</button>
    <button id="download-ciphertext" class="action"> ⬇ download</button>
    </span>
    </p>
    <p id="ciphertext-error-bar"></p>
    <textarea id="ciphertext" autocomplete="off" placeholder="Click here to paste some text to decrypt"></textarea>
</div>

<!-- invisible anchor used to trigger the download dialog -->
<a id ="download-dialog-anchor" href="" style="display:none"></a>

</main>

<p id="error-bar"></p>
<div id="overlay" class="is-hidden"><div id="spinner"></div></div>

<script id="the-script">

function stringToUint8Array(text) {
    return new TextEncoder().encode(text);
}

function bufToString(arr) {
    return new TextDecoder().decode(arr);
}

function atob_exceptional(ascii) {
    try { return atob(ascii); }
    catch (e) { throw new Base64DecodeError(); }
}

class Base64DecodeError extends Error {};

function u_atob(ascii) {
    return Uint8Array.from(atob_exceptional(ascii), c => c.charCodeAt(0));
}

function u_btoa(buffer) {
    var binary = [];
    var bytes = new Uint8Array(buffer);
    for (var i = 0, il = bytes.byteLength; i < il; i++) {
        binary.push(String.fromCharCode(bytes[i]));
    }
    return btoa(binary.join(''));
}

function bufToHex(buffer) {
    return new Uint8Array(buffer).reduce((a, b) => a + ('0' + b.toString(16)).slice(-2), '');
}

function hexToBuf(text) {
    return new Uint8Array(text.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
}

function getRandomHexString(length) {
    const array = new Uint8Array(Math.ceil(length/2));
    window.crypto.getRandomValues(array);
    return bufToHex(array).slice(0, length);
}

async function willGenerateKeyPBKDF2(secret) {
    if (!secret) {
        // Firefox doesn't allow it, Chrome does. Let's make it consistent.
        throw new GenerateKeyError('Cannot generate a key using an empty secret');
    }

    try {
        return await crypto.subtle.importKey(
            'raw',
            stringToUint8Array(secret),
            { name: 'PBKDF2' },
            false, // whether the key can be extracted or not
            [ 'deriveKey' ]
        );
    } catch (e) {
        throw new GenerateKeyError(e.message || e.name);
    }
}

class GenerateKeyError extends Error {};

async function willDeriveKey(baseKey, {saltString, iterations}) {
    try {
        return await crypto.subtle.deriveKey(
            {
                name: 'PBKDF2',
                salt: stringToUint8Array(saltString),
                iterations: iterations,
                hash: 'SHA-256'
            },
            baseKey,
            { "name": 'AES-GCM', "length": 256 },
            false, // whether the key can be extracted or not
            [ "encrypt", "decrypt" ]
        );
    }
    catch (e) {
        throw new DeriveKeyError(e.message || e.name);
    }
}

class DeriveKeyError extends Error {};

/**
 * Encrypt text using 256 AES in GCM mode, deriving the key with PBKDF2.
 *
 * @param string plaintext the text to encrypt
 * @param string secret the secret to use to derive the key with PBKDF2
 * @param array optionsPBKDF2
 *              - string salt use it to prevent dictionary attacks
 *              - number iterations the number of PBKDF2 iterations to derive the key
 * @param arrayBuffer b_iv a nonce to use in AES-GCM
 * @return Promise that will resolve to our encrypted box format.
 *
 * The encrypted box is formed by 2 base64 encoded parts (additional data,
 * ciphertext), separated by a dot.
 *
 * The additional data is a JSON object containing everything required to
 * decode the ciphertext, minus the key.
 * It has the following format:
 *   {
 *     "opt_pbkdf2": { "salt": "<some salt>", "iterations": <some number> },
 *     "iv": "iv, as hex",
 *   }
 *
 * >>> willEncryptPlaintext(
 * >>>     'the text to encrypt',
 * >>>     'your strong secret',
 * >>>     {
 * >>>         salt: 'string to make your key unique even if your secret was more common than you thought',
 * >>>         iterations: 60000,
 * >>>     },
 * >>>     new Uint8Array([0,1,...,11]) // 96 bit nonce
 * >>> ).then(function (result) {
 * >>>     console.log(result); // abc.def.ghi
 * >>> });
 */
async function willEncryptPlaintext(plaintext, secret, optionsPBKDF2, b_iv) {
    const baseKey = await willGenerateKeyPBKDF2(secret);
    const derivedKey = await willDeriveKey(baseKey, optionsPBKDF2);
    const b_ad = stringToUint8Array(JSON.stringify({
        opt_pbkdf2: optionsPBKDF2,
        iv: bufToHex(b_iv),
    }));

    const b_enc = await crypto.subtle.encrypt(
        {
            name: 'AES-GCM',
            iv: b_iv,
            additionalData: b_ad,
        },
        derivedKey,
        stringToUint8Array(plaintext)
    );

    return u_btoa(b_ad) + '.' + u_btoa(b_enc);
}

function json_parse_exceptional(string) {
    try { return JSON.parse(string); }
    catch (e) { throw new JSONDecodeError(); }
}

class JSONDecodeError extends Error {};

function crypto_subtle_decrypt_exceptional(algorithm, key, data) {
    return crypto.subtle.decrypt(algorithm, key, data)
    .catch(e => { throw new SubtleDecryptError; });
}

class SubtleDecryptError extends Error {};

/**
 * Decrypt data using 256 AES in GCM mode, deriving the key with PBKDF2.
 *
 * @param string ciphertext the text to decrypt, as produced by willEncryptPlaintext
 * @param string secret the secret to use to derive the key with PBKDF2
 *
 * @return Promise that will resolve to an object with format {plaintext,
 * additionalData, iv}
 *
 */
async function willDecryptCiphertext(encryptedBox, secret) {
    const [b64_ad = '', b64_enc = ''] = encryptedBox.split('.');
    const [b_ad, b_enc] = [b64_ad, b64_enc].map(u_atob);
    const additionalData = json_parse_exceptional(bufToString(b_ad));
    const b_iv = hexToBuf(additionalData.iv);

    const optionsPBKDF2 = {
        salt: (additionalData.opt_pbkdf2 || {}).salt || '',
        iterations: (additionalData.opt_pbkdf2 || {}).iterations || 1,
    };

    const baseKey = await willGenerateKeyPBKDF2(secret);
    const derivedKey = await willDeriveKey(baseKey, optionsPBKDF2);
    const b_dec = await crypto_subtle_decrypt_exceptional(
        {
            name: 'AES-GCM',
            iv: b_iv,
            additionalData: b_ad,
        },
        derivedKey,
        b_enc
    );

    return {
        plaintext: bufToString(b_dec),
        additionalData,
        iv: b_iv,
    };
}

function willRequestEncryption(plaintext) {
    if (!plaintext) return '';
    const secret = getValueAt('secret');
    const b_iv = window.crypto.getRandomValues(new Uint8Array(12));
    const optionsPBKDF2 = {
        salt: getPBKDF2Salt(),
        iterations: getPBKDF2Iterations(),
    };

    return willEncryptPlaintext(plaintext, secret, optionsPBKDF2, b_iv);
}

function triggerDownloadDialog(blob, filename) {
    const url = window.URL.createObjectURL(blob);
    const anchor = $('download-dialog-anchor');

    anchor.href = url;
    anchor.download = filename;
    anchor.click();
    window.URL.revokeObjectURL(url);
}

/**
 * Return a string with the format YYYY-MM-DD_HHMMSS
 */
function makeDateTimePrefix(date) {
    const isoDateTime = date.toISOString();
    const datePart = isoDateTime.split('T')[0];
    const timePart = isoDateTime.split('T')[1].split('.')[0];

    return datePart + '_' + timePart.replace(/:/g, '');
}

const $ = id => document.getElementById(id);
const setValueAt = (id, value) => $(id).value = value;
const getValueAt = (id) => $(id).value;

const getPBKDF2Salt = () => window.getRandomHexString(16);
const getPBKDF2Iterations = () => PBKDF2_ITERATIONS;

const pushErrorToDisplayQueue = (e) => {
    const errorMessage = e.message || e.name || 'Unknown error';
    if (errorMessage != ERRORS_QUEUE.slice(-1)[0]) {
        ERRORS_QUEUE.push(errorMessage);
    }
    displayErrorBanner();
};

const discardLatestError = () => {
    ERRORS_QUEUE.pop();
    displayErrorBanner();
};

const displayErrorBanner = () => {
    const errorMessage = ERRORS_QUEUE.slice(-1)[0];
    $('error-bar').classList.replace('bump', 'no-bump');
    setTimeout(() => {
        $('error-bar').innerText = errorMessage || '';
        $('error-bar').classList.replace('no-bump', 'bump');
    }, 10);
};

const toggleOverlay = (isVisible) => {
    $('overlay').classList.toggle('is-hidden', !isVisible);
};

const ciphertextHasError = () => $('ciphertext').classList.contains('has-error');
const setCiphertextError = (errorMessage) => {
    const hasError = Boolean(errorMessage.trim());
    $('ciphertext').classList.toggle('has-error', hasError);
    $('ciphertext-error-bar').innerText = errorMessage;
};

const encryptPlaintextAndSetCiphertext = async function() {
    try {
        const ciphertext = await willRequestEncryption(getValueAt('plaintext'));
        setValueAt('ciphertext', ciphertext);
        setCiphertextError('');
    } catch (e) {
        pushErrorToDisplayQueue(e);
    }
};

const getDOMElementsWhoseValuesAreUsedToEncrypt = () => document.querySelectorAll('.change-ciphertext');

async function updatePlaintextFromCiphertext() {
    setCiphertextError('');
    try {
        const secret = getValueAt('secret');
        const ciphertext = getValueAt('ciphertext');
        let plaintext = '';

        if (ciphertext) {
            const result = await willDecryptCiphertext(ciphertext, secret);
            plaintext = result.plaintext;
        }

        setValueAt('plaintext', plaintext);
    } catch (e) {
        if (!(e instanceof JSONDecodeError
            || e instanceof Base64DecodeError
            || e instanceof SubtleDecryptError)) {
            console.error(e);
        }
        setCiphertextError('Cannot decrypt, most likely the ciphertext is not correct: focus the cleartext to refresh the ciphertext');
    };
}

async function onDownloadCiphertextButtonClicked(ev) {
    ev.preventDefault();

    const encryptedBox = await willRequestEncryption(getValueAt('plaintext'));
    const blob = new Blob([encryptedBox], {type: "plain/text"});
    const filename = makeDateTimePrefix(new Date()) + '_encrypted_vanillacrypto.txt';

    triggerDownloadDialog(blob, filename);
}

function onDownloadCleartextButtonClicked(ev) {
    ev.preventDefault();

    const blob = new Blob([getValueAt('plaintext')], {type: "plain/text"});
    const filename = makeDateTimePrefix(new Date()) + '_cleartext_vanillacrypto.txt';

    triggerDownloadDialog(blob, filename);
}

async function onReloadCiphertextButtonClicked(ev) {
    ev.preventDefault();
    toggleOverlay(true);
    try {
        await reloadFile();
        toggleOverlay(false);
    } catch (e) {
        pushErrorToDisplayQueue(e);
        toggleOverlay(false);
    }
}

async function _willGetAuthToken() {
    try {
        // user exists, we've got a challenge to decrypt
        const challenge = (await willRequestChallenge()).content.challenge;
        return (await willAnswerChallenge(challenge)).content.token;
    } catch (e) {
        if (e instanceof UserDoesNotExistError) {
            if (!window.confirm('No user found with that username, would you like to create it?')) {
                throw new Error('Cannot proceed');
            }

            return (await willCreateNewUser()).content.token;
        } else if (e instanceof SubtleDecryptError) {
            throw new Error('The password is not correct');
        } else {
            throw e;
        }
    }
}

/**
 * Retrieve an authorization token.
 *
 * The token is cached unless the option {refresh: true} is provided.
 * Use fetchJSONWithRetryOnAuthExpired() to automatically refresh it.
 */
const willGetAuthToken = (() => {
    let token = null;

    return async function(options) {
        if (!token || (options || {}).refresh) {
            token = await _willGetAuthToken();
        }
        return token;
    };
})();

async function willRequestChallenge() {
    const url = new URL(STORE_URL + '/auth/request-challenge');
    url.searchParams.append('username', getValueAt('username'));

    const parsedResponse = await fetchJSON(url.href);

    if (parsedResponse.error) {
        if (parsedResponse.error.code === 1005) {
            throw new UserDoesNotExistError();
        }
        throw new CannotRequestChallengeError(parsedResponse.error);
    }

    return parsedResponse;
}

class UserDoesNotExistError extends Error {}

async function willAnswerChallenge(challenge) {
    const answerBox = await willDecryptCiphertext(challenge, getValueAt('secret'));
    const answer = answerBox.plaintext;

    const url = new URL(STORE_URL + '/auth/answer-challenge');
    const parsedResponse = await fetchJSONWithRetryOnAuthExpired(url.href, {
        method: 'POST',
        body: JSON.stringify({
            username: getValueAt('username'),
            answer,
        }),
    });

    if (parsedResponse.error) {
        throw new CannotAnswerChallengeError(parsedResponse.error);
    }

    return parsedResponse;
}

async function willCreateNewUser() {
    const h_answer = getRandomHexString(32);
    const url = new URL(STORE_URL + '/users/');
    const parsedResponse = await fetchJSON(url.href, {
        method: 'POST',
        body: JSON.stringify({
            username: getValueAt('username'),
            challenge: await willRequestEncryption(h_answer),
            answer: h_answer,
        }),
    });

    if (parsedResponse.error) {
        throw new CannotCreateNewUserError(parsedResponse.error);
    }

    return parsedResponse;
}

class CannotCreateNewUserError extends Error {
    constructor(jsonError) {
        super();
        this.message = 'Couldn\'t create the user. Server response was: ' +
        '[' + jsonError.code + '] ' + jsonError.message;
    }
}

class CannotRequestChallengeError extends Error {
    constructor(jsonError) {
        super();
        this.message = 'Couldn\'t start authentication. Server response was: ' +
        '[' + jsonError.code + '] ' + jsonError.message;
    }
}

class CannotAnswerChallengeError extends Error {
    constructor(jsonError) {
        super();
        this.message = 'Couldn\'t authenticate. Server response was: ' +
        '[' + jsonError.code + '] ' + jsonError.message;
    }
}

const getFilenameOrDefault = (() => {
    let _filename = null;
    return ((defaultFilename) => {
        if (!_filename) {
            _filename = defaultFilename || getRandomHexString(32);
        }
        return _filename;
    });
})();

async function onUploadCiphertextButtonClicked(ev) {
    ev.preventDefault();

    // XXX this is ok as long as we support just a single file
    const filename = getFilenameOrDefault();

    toggleOverlay(true);

    try {
        const ciphertext = await willRequestEncryption(getValueAt('plaintext')); // XXX this way we upload something different from what the user sees !!!!
        const { uploadUrl, uploadFormData, retrieveUrl } = await willRequestUploadUrl(filename);
        if (uploadUrl.slice(0, TRUSTED_UPLOAD_BASE_URL.length) !== TRUSTED_UPLOAD_BASE_URL) {
            throw new Error('The server proposed to upload the file to an untrusted url!');
        }
        await willUploadCiphertext(uploadUrl, uploadFormData, ciphertext);

        const uploadedContent = await willDownload(retrieveUrl);
        if (uploadedContent !== ciphertext) {
            throw new Error('The uploaded file does not match the original file');
        }
        console.log('Cool, the file was uploaded correctly!');
    } catch (e) {
        if (e instanceof UploadCiphertextError
            || e instanceof CannotRequestUploadUrlError) {
            pushErrorToDisplayQueue(e);
        } else {
            console.error('Error uploading the ciphertext', e);
            pushErrorToDisplayQueue(new Error('Error uploading the ciphertext'));
        }
    }

    toggleOverlay(false);
};

async function reloadFile() {
    try {
        const files = await willGetFilesList();
        let ciphertext = '';
        if (files.length > 0) {
            getFilenameOrDefault(files[0].content.filename);
            ciphertext = await willDownload(files[0].links.read.href);
        }
        setValueAt('ciphertext', ciphertext);
        updatePlaintextFromCiphertext();
    } catch (e) {
        if (e instanceof CannotRetrieveFilesListError) {
            throw e;
        } else if (e instanceof DownloadError) {
            throw e;
        } else {
            console.error(e);
            throw new Error('An error occurred while reloading the ciphertext');
        }
    }
}

async function willRequestUploadUrl(filename) {
    const href = STORE_URL + '/files/request-upload-url';
    const token = await willGetAuthToken();
    const parsedResponse = await fetchJSONWithRetryOnAuthExpired(href, {
        method: 'POST',
        body: JSON.stringify({
            filename: filename,
        }),
        headers: {
            Authorization: `Bearer ${token}`,
        },
    });

    if (parsedResponse.error) {
        throw new CannotRequestUploadUrlError(parsedResponse.error);
    }

    return {
        uploadUrl: parsedResponse.links.upload_url.href,
        uploadFormData: parsedResponse.links.upload_url.form_data,
        retrieveUrl: parsedResponse.links.retrieve_url.href,
    };
}

class CannotRequestUploadUrlError extends Error {
    constructor(jsonError) {
        super();
        this.message = 'Cannot get the url to upload to. Server response was: ' +
        '[' + jsonError.code + '] ' + jsonError.message;
    }
}

async function willUploadCiphertext(uploadUrl, uploadFormData, ciphertext) {
    try {
        const formData = new FormData();
        for (let [key, value] of Object.entries(uploadFormData)) {
            formData.append(key, value);
        }
        const blob = new Blob([ciphertext], { type: "text/plain"});
        formData.append("file", blob);

        const response = await fetchOrThrow(uploadUrl, {
            headers: {
                'Cache-Control': 'None',
                'Expect': '100-continue',
                'Content-Encoding': 'utf-8',
                // XXX ... no md5 in crypto subtle, so we can't rely on it.
                // We'll have to download the file and verify his content later
                // 'Content-MD5': 'application/json',
            },
            method: 'POST',
            body: formData,
        });

        if (!response.ok) {
            const responseContent = await response.text();
            const errorDoc = (new window.DOMParser()).parseFromString(responseContent, "application/xml");
            const errorMessageElem = errorDoc.querySelector('Error > Message');
            const errorMessage = errorMessageElem === null ? responseContent : errorMessageElem.textContent;

            throw new UploadCiphertextError('Couldn\'t upload the ciphertext, response was: ' + `${errorMessage}`);
        }

        return response;
    } catch (e) {
        if (e instanceof FetchUnexpectedError
            || e instanceof FetchRequestTimedOutError) {
            throw new UploadCiphertextError(e.message);
        } else {
            throw e;
        }
    }
}

class UploadCiphertextError extends Error {};

async function willDownload(href) {
    const response = await fetchOrThrow(href, {
        mode: 'cors',
        cache: 'no-store',
        referrerPolicy: 'no-referrer',
    });

    if (response.ok) {
        return response.text();
    } else {
        throw new DownloadError(response.statusText);
    }
}

class DownloadError extends Error {
    constructor(statusText) {
        super();
        this.message = 'Couldn\'t download the file. Server response was: ' + statusText;
    }
}

async function willGetFilesList() {
    const href = STORE_URL + '/files/';
    const token = await willGetAuthToken();
    const jsonResponse = await fetchJSONWithRetryOnAuthExpired(href, {
        headers: {
            Authorization: `Bearer ${token}`,
        },
    });
    if (jsonResponse.error) { throw new CannotRetrieveFilesListError(jsonResponse.error); }
    return jsonResponse.content;
}

async function fetchJSONWithRetryOnAuthExpired(href, options) {
    let response = await fetchJSON(href, options);
    if (response.error && response.error.code === 1007) {
        // 1007 means "token expired"
        await willGetAuthToken({refresh: true});
        response = await fetchJSON(href, options);
    }
    return response;
}

class FetchUnexpectedError extends Error {
    constructor(orig) {
        super();
        this.message = "Cannot fetch an external resource: check your internet connection or configuration";
        this.details = orig;
    }
}
class FetchRequestTimedOutError extends Error {
    constructor() {
        super();
        this.message = "The request is taking too long to complete";
    }
}
class FetchUnexpectedFormat extends Error {
    constructor(statusText) {
        super();
        this.message = statusText;
    }
}

class CannotRetrieveFilesListError extends Error {
    constructor(jsonError) {
        super();
        this.message = 'Cannot retrieve the files\' list. Server response was: ' +
        '[' + jsonError.code + '] ' + jsonError.message;
    }
}

async function fetchOrThrow(href, options) {
    const request = fetch(href, options)
    .catch (e => { throw new FetchUnexpectedError(e); });
    const timeout = new Promise((resolve, reject) => {
        // XXX we should abort the request on timeout
        setTimeout(() => reject(new FetchRequestTimedOutError()), 15000);
    });
    return Promise.race([timeout, request]);
}

async function fetchJSON(href, options = {}) {
    options = {
        mode: 'cors',
        cache: 'no-store',
        referrerPolicy: 'no-referrer',
        ...options,
        headers: {
            ...options.headers,
            'Content-Type': 'application/json',
        },
    };

    const response = await fetchOrThrow(href, options);

    if (response.headers.get('Content-Type') === 'application/json') {
        return response.json();
    } else {
        throw new FetchUnexpectedFormat(response.statusText);
    }
}

async function attemptLogin() {
    if (getValueAt('confirm-secret') !== getValueAt('secret')) {
        window.alert('The passwords don\'t match');
    } else {
        toggleOverlay(true);
        try {
            if (getValueAt('username')) {
                // auth, possibly ask to create the user
                const token = await willGetAuthToken();
                await reloadFile();
            } else {
                document.body.classList.remove('enable-external-actions');
            }
            document.body.classList.remove('require-login');
        } catch (e) {
            pushErrorToDisplayQueue(e);
        }
        toggleOverlay(false);
    }
}

function poorDebounce(func, wait) {
    let timeoutId = null;
    return function() {
        const args = arguments;
        if (timeoutId) {
            clearInterval(timeoutId);
            timeoutId = null;
        }
        timeoutId = setTimeout(() => func.apply(null, args), wait || 50);
    };
}

function onPageLoaded() {
    $('error-bar').addEventListener('click', (ev) => discardLatestError());
    // encrypt plaintext on focus only when there are errors, otherwise with a random IV we would
    // change the ciphertext without reason
    $('plaintext').addEventListener('focus', ev => {
        if (ciphertextHasError()) { encryptPlaintextAndSetCiphertext(); }
    });
    // redo encryption if any of the fields used to encrypt has changed
    getDOMElementsWhoseValuesAreUsedToEncrypt().forEach(elem => {
        elem.addEventListener('input', poorDebounce(ev => encryptPlaintextAndSetCiphertext()));
    });
    // redo decryption if the ciphertext has changed (or may have changed)
    ['input', 'focus'].forEach(eventType => {
        $('ciphertext').addEventListener(eventType, poorDebounce(ev => updatePlaintextFromCiphertext()));
    });

    $('download-ciphertext').addEventListener('click', onDownloadCiphertextButtonClicked);
    $('download-cleartext').addEventListener('click', onDownloadCleartextButtonClicked);
    $('reload-ciphertext').addEventListener('click', onReloadCiphertextButtonClicked);
    $('upload-ciphertext').addEventListener('click', onUploadCiphertextButtonClicked);

    [$('secret'), $('confirm-secret')].forEach((elem) => {
        const loginBtn = $('login-btn');

        elem.addEventListener('input', () => {
            loginBtn.disabled = getValueAt('confirm-secret') !== getValueAt('secret');
        });
    });

    $('login-form').addEventListener('submit', ev => ev.preventDefault() || attemptLogin());

    $('logout-btn').addEventListener('click', () => {
        document.location.reload();
    });
}

</script>
</body>
</html>