<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<script>
// Salt, a random string, at least 8 characters long. It ensures that
// the derived key will be different even if two people have the same
// password.
const PBKDF2_SALT = '';
// Iteration count for PBKDF2. At least 10000. The higher the value
// the longer you'll need to wait after entering the password to
// derive the key used for encryption.
const PBKDF2_ITERATIONS = 60000;
</script>
<style>

html {
    background-color: #cad8d9;
}

body {
    box-sizing: border-box;
    width: 100%;
    padding: 1em;
    margin: 0 auto;
}

input[type=checkbox] {
    margin: 0;
}

fieldset {
    margin: 0;
    padding: 1em;
    border: 0;
}

legend {
    margin: 0;
    padding: 0;
    font-weight: bold;
}

.main-container {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
}

.options-container {
    display: flex;
    flex: 1 1 100%;
    align-items: center;
    flex-wrap: wrap;
    flex-direction: column;
}

.pbkdf2-options {
    display: flex;
    flex: 1 1 100%;
    flex-wrap: wrap;
}

.pbkdf2-salt-line {
    display: flex;
    flex: 1 1 100%;
    align-items: center;
}

.pbkdf2-salt-line > input{
    flex: 1;
}

.pbkdf2-iterations-line {
    display: flex;
    flex: 1 1 100%;
    align-items: center;
}

.pbkdf2-iterations-line > input{
    flex: 1;
}


.informations {
    display: block;
    flex: 1 1 100%;
    margin-top: 1em;
}

.secret-container {
    display: flex;
    align-items: center;
}

.iv-container {
    display: flex;
    flex: 1 1 100%;
    flex-direction: row;
    align-items: center;
}

.iv-container > label {
    margin-right: 1em;
}

#secret {
    box-sizing: border-box;
    padding: 0 0.2em;
    width: 30em;
    margin-right: 0.2em;
}

label {
    cursor: pointer;
}

#show-secret {
    display: none;
}

#show-secret:checked + label{
    color: red;
}

textarea, button {
    box-sizing: border-box;
}

input[type=text], input[type=password] {
    padding: 0 0.3em;
}

.plaintext-container, .ciphertext-container {
    display: flex;
    flex: 1 1 35%;
    flex-direction: column;
    align-items: center;
}

#plaintext, #ciphertext {
    min-height: 400px;
    width: 90%;
}

.error {
    color: red;
}

span.error:empty:before {
    content: "\200b"; /* unicode zero width space character */
}

.advanced-options {
    display: flex;
    flex: 1 1 100%;
    margin-top: 1em;
    flex-direction: column;
    align-items: center;
}

.advanced-options .content {
    transition: max-height 0.4s ease-out;
    max-height: 0;
    opacity: 1;
    overflow: hidden;
}

.advanced-options.is-active .content {
    max-height: 300px;
    opacity: 1;
}

.advanced-options .toggle-icon {
    transition: transform 0.4s;
    display: inline-block;
}

.advanced-options.is-active .toggle-icon {
    transform: rotate(90deg);
}

.advanced-options-legend {
    cursor: pointer;
}

.field-name {
    display: flex;
    flex: 0.2;
}

</style>
</head>
<body>

<div class="main-container">
    <div class="options-container">
        <span class="secret-container">
            <label>Password <input id="secret" type="password" class="change-ciphertext" /></label>
            <input
                id="show-secret"
                type="checkbox"
                onchange="document.getElementById('secret').type = this.checked ? 'text' : 'password'"
                title="Show password"
            />
            <label for="show-secret">üëÅ</label>
        </span>

    </div>
    <div class="plaintext-container">
        <h2>Plaintext</h2>
        <span id="plaintext-error-message" class="error"></span>
        <textarea id="plaintext" class="change-ciphertext"></textarea>
    </div>
    <div class="ciphertext-container">
        <h2>Ciphertext</h2>
        <span id="ciphertext-error-message" class="error"></span>
        <textarea id="ciphertext"></textarea>
    </div>

    <fieldset class="advanced-options">
        <legend class="advanced-options-legend"><span class="toggle-icon">‚ñ∂</span> Advanced options</legend>

        <div class="content">

            <fieldset>
                <legend>Key derivation function - PBKDF2</legend>
                <div class="pbkdf2-options">
                    <label class="pbkdf2-salt-line">
                        <span class="field-name">Salt</span>
                        <span id="pbkdf2-salt"></span>
                    </label>
                    <label class="pbkdf2-iterations-line">
                        <span class="field-name">Iterations</span>
                        <span id="pbkdf2-iterations"></span>
                    </label>
                </div>
            </fieldset>

            <fieldset>
                <legend>Encryption</legend>
                <div class="iv-options">
                    <span class="iv-container">
                        <label>IV (initialization vector)
                            <span id="iv"></span>
                        </label>
                    </span>
                </div>
            </fieldset>
        </div>

    </fieldset>
</div>

<script>

    function stringToUint8Array(text) {
        return new TextEncoder().encode(text);
    }

    function bufToString(arr) {
        return new TextDecoder().decode(arr);
    }

    function buf2hex(bufferSource) {
        return Array.from(new Uint8Array(bufferSource)).map(x => ('00' + x.toString(16)).slice(-2)).join('');
    }

    function hexToUint8Array(hex) {
        for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
        return new Uint8Array(bytes);
    }

    function willGenerateKeyPBKDF2(secret) {
        return crypto.subtle.importKey(
            'raw',
            stringToUint8Array(secret),
            { name: 'PBKDF2' },
            false, // whether the key can be extracted or not
            [ 'deriveBits', 'deriveKey' ]
        );
    }

    function willDeriveKey(baseKey, {saltString, iterations}) {
        return crypto.subtle.deriveKey(
            {
                name: 'PBKDF2',
                salt: stringToUint8Array(saltString),
                iterations: iterations,
                hash: 'SHA-256'
            },
            baseKey,
            { "name": 'AES-GCM', "length": 256 },
            false, // whether the key can be extracted or not
            [ "encrypt", "decrypt" ]
        );
    }

    function willEncryptAESGCM(key, params) {
        const { iv, additionalData, plaintext } = params;
        const adAsBytes = stringToUint8Array(JSON.stringify(additionalData));

        return crypto.subtle.encrypt(
            {
                name: 'AES-GCM',
                iv,
                additionalData: adAsBytes,
            },
            key,
            stringToUint8Array(plaintext)
        ).then(enc => {
            return [
                buf2hex(adAsBytes),
                buf2hex(iv),
                buf2hex(enc), // ciphertext | tag
            ].join('.');
        });
    }

    function willDecryptAESGCM(key, encTransportBlock) {
        const [adAsHex = '', ivAsHex = '', ciphertextPlusTag = ''] = encTransportBlock.split('.');

        return crypto.subtle.decrypt(
            {
                name: 'AES-GCM',
                iv: hexToUint8Array(ivAsHex),
                additionalData: hexToUint8Array(adAsHex)
            },
            key,
            hexToUint8Array(ciphertextPlusTag)
        ).then(dec => ({
            plaintext: bufToString(dec),
            additionalData: JSON.parse(bufToString(hexToUint8Array(adAsHex))),
            iv: hexToUint8Array(ivAsHex),
        }));
    }

    /**
     * Encrypt plaintext using 256 AES in CBC mode, deriving the key with PBKDF2.
     *
     * @param string plaintext the text to encrypt
     * @param string secret the secret to use to derive the key with PBKDF2
     * @param array optionsPBKDF2
     *              - string salt use it to prevent dictionary attacks
     *              - number iterations the number of PBKDF2 iterations to derive the key
     * @param arrayBuffer iv a nonce to use in AES-GCM
     * @return Promise that will resolve to an array with keys iv, ciphertext, whose values are hexstrings
     *
     * >>> // example
     * >>>
     * >>> willEncryptPlaintext(
     * >>>     'the text to encrypt',
     * >>>     'your strong secret',
     * >>>     {
     * >>>         salt: 'string to make your key unique even if your secret was more common than you thinked',
     * >>>         iterations: 60000,
     * >>>     },
     * >>>     new Uint8Array([0,1,...,11]) // 96 bit nonce
     * >>> ).then(function (result) {
     * >>>     console.log(result); // e.g. "<additional data as hex>.<iv as hex>.<ciphertext as hex>"
     * >>> });
     */
    function willEncryptPlaintext(plaintext, secret, optionsPBKDF2, iv) {
        return willGenerateKeyPBKDF2(secret)
        .then(function (baseKey) {
            return willDeriveKey(baseKey, optionsPBKDF2);
        })
        .then(function (derivedKey) {
            return willEncryptAESGCM(derivedKey, {
                iv,
                plaintext,
                additionalData: optionsPBKDF2
            });
        });
    }

    /**
     * Decrypt ciphertext using 256 AES in CBC mode, deriving the key with PBKDF2.
     *
     * @param string ciphertext the text to encrypt
     * @param string secret the secret to use to derive the key with PBKDF2
     * @param array optionsPBKDF2
     *              - string salt the string used alongside the secret to derive the key
     *              - number iterations the number of PBKDF2 iterations used to derive the key
     * @return Promise that will resolve to an object with key plaintext, whose value is the plaintext as string
     */
    function willDecryptCiphertext(ciphertext, secret, optionsPBKDF2) {
        return willGenerateKeyPBKDF2(secret)
        .then(function (baseKey) {
            return willDeriveKey(baseKey, optionsPBKDF2);
        })
        .then(function (derivedKey) {
            return willDecryptAESGCM(derivedKey, ciphertext);
        });
    }

    function requestEncryption() {
        let secret = getSecret();
        let plaintext = getPlaintext();
        let iv = window.crypto.getRandomValues(new Uint8Array(16));
        let optionsPBKDF2 = {
            salt: getPBKDF2Salt(),
            iterations: getPBKDF2Iterations(),
        };

        willEncryptPlaintext(plaintext, secret, optionsPBKDF2, iv)
        .then(setCiphertext);
    }

    function requestDecryption() {
        let ciphertext = getCiphertext();
        let secret = getSecret();
        let optionsPBKDF2 = {
            salt: getPBKDF2Salt(),
            iterations: getPBKDF2Iterations(),
        };

        if (ciphertext === '') {
            setPlaintext('');
            return;
        }

        willDecryptCiphertext(ciphertext, secret, optionsPBKDF2)
        .catch(function(e) {
            setCiphertextErrorMessage('The operation failed (most likely the ciphertext is not correct)');
            setPlaintextErrorMessage(
                'The plaintext does not reflect the ciphertext (focus the textarea to refresh)'
            );

            if (!e instanceof DOMException) {
                throw e;
            }
        })
        .then(function (result) {
            setPlaintext(result.plaintext);
        });
    }

    let getPlaintextDOMElement = () => document.getElementById('plaintext');
    let getPlaintext = () => getPlaintextDOMElement().value;
    let setPlaintext = value => getPlaintextDOMElement().value = value;

    let getCiphertextDOMElement = () => document.getElementById('ciphertext');
    let getCiphertext = () => getCiphertextDOMElement().value;
    let setCiphertext = value => getCiphertextDOMElement().value = value;

    let getSecretDOMElement = () => document.getElementById('secret');
    let getSecret = () => getSecretDOMElement().value;

    let getIVDOMElement = () => document.getElementById('iv');
    let setIVLabel = value => getIVDOMElement().innerText = value;

    let getPBKDF2SaltDOMElement = () => document.getElementById('pbkdf2-salt');
    let getPBKDF2Salt = () => PBKDF2_SALT;

    let getPBKDF2IterationsDOMElement = () => document.getElementById('pbkdf2-iterations');
    let getPBKDF2Iterations = () => PBKDF2_ITERATIONS;

    let getCiphertextErrorMessageDOMElement = () => document.getElementById('ciphertext-error-message');
    let getCiphertextErrorMessage = message => getCiphertextErrorMessageDOMElement().innerText.trim();
    let setCiphertextErrorMessage = message => getCiphertextErrorMessageDOMElement().innerText = message;

    let getPlaintextErrorMessageDOMElement = () => document.getElementById('plaintext-error-message');
    let getPlaintextErrorMessage = message => getPlaintextErrorMessageDOMElement().innerText.trim();
    let setPlaintextErrorMessage = message => getPlaintextErrorMessageDOMElement().innerText = message;

    let clearErrorMessages = () => {
        setCiphertextErrorMessage('');
        setPlaintextErrorMessage('');
    };

    let hasErrors = () => Boolean(getPlaintextErrorMessage() || getCiphertextErrorMessage());

    getPBKDF2SaltDOMElement().innerText = getPBKDF2Salt() || '<empty>';
    getPBKDF2IterationsDOMElement().innerText = getPBKDF2Iterations();

    // encrypt on focus only when there are errors, otherwise with a random IV we would
    // change the ciphertext without reason
    getPlaintextDOMElement().addEventListener('focus', ev => {
        if (hasErrors()) {
            clearErrorMessages();
            requestEncryption();
        }
    });

    getDOMElementsWhoseValuesAreUsedToEncrypt = () => document.querySelectorAll('.change-ciphertext');

    // redo encryption if any of the fields used to encrypt has changed
    getDOMElementsWhoseValuesAreUsedToEncrypt().forEach(elem => {
        let eventType = 'input';

        if (elem.type === 'checkbox') {
            eventType = 'change';
        }

        elem.addEventListener(eventType, ev => { clearErrorMessages(); requestEncryption(); });
    });

    // redo decryption if the ciphertext has changed (or may have changed)
    ['input', 'focus'].forEach(eventType => {
        getCiphertextDOMElement().addEventListener(eventType, ev => { clearErrorMessages(); requestDecryption(); });
    });

    document.querySelector('.advanced-options-legend').addEventListener('click', ev => {
        return document.querySelector('.advanced-options').classList.toggle('is-active');
    });

</script>
</body>
</html>