<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<script>
// Salt, it ensures that two people with the same password will generate
// different secret keys. It should be at least 8 random characters long.
const PBKDF2_SALT = new URLSearchParams(document.location.search).get('salt')
      || ''; // <== insert the salt inside the two '' on the far left
// Iteration count for PBKDF2. At least 10000. The higher the value
// the longer you'll need to wait after entering the password to
// derive the key used for encryption.
const PBKDF2_ITERATIONS = new URLSearchParams(document.location.search).get('iterations')
      || 60000;
// Url fo the service (an instance of Piggy Store) where you could optionally
// store your encrypted data
const STORE_URL = 'http://localhost:5000';
const TRUSTED_UPLOAD_BASE_URL = 'http://localhost:9000/'
const ERRORS_QUEUE = [];
</script>
<style>

html {
    background-color: #cad8d9;
    font-family: Verdana, Geneva, Tahoma, sans-serif;
    background: #32393F;
    height: 100%;
}

body {
    box-sizing: border-box;
    max-width: 1200px;
    width: 100%;
    padding: 1em;
    margin: 0 auto;
    display: flex;
    justify-content: center;
    flex-direction: column;
    min-height: 100%;
}

p {
    margin: 0;
}

.main-container {
    display: flex;
    width: 100%;
    flex: 1 0 auto;
    flex-wrap: wrap;
}

#secret {
    box-sizing: border-box;
    padding: 0 0.2em;
    margin-right: 0.2em;
}

label {
    cursor: pointer;
}

textarea, button {
    box-sizing: border-box;
}

button {
    padding: 0 0.9em;
}

button::-moz-focus-inner,
input[type="button"]::-moz-focus-inner,
input[type="submit"]::-moz-focus-inner,
input[type="reset"]::-moz-focus-inner {
  padding: 0 !important;
  border: 0 none !important;
}

input[type=text], input[type=password] {
    padding: 0 0.3em;
}

.plaintext-container, .ciphertext-container {
    box-sizing: border-box;
    padding: 0 1em;
    display: flex;
    flex: 1 1 50%;
    flex-direction: column;
    min-width: 360px;
    margin-top: 1em;
}

.plaintext-container > textarea,
.ciphertext-container > textarea {
    flex: 1 1 100%;
}

#plaintext, #ciphertext {
    min-height: 70vh;
}

#ciphertext {
    font-family: Andale Mono, AndaleMono, Consolas, Monaco, monospace;
}

#ciphertext-error-bar {
    color: red;
}

span.error:empty:before {
    content: "\200b"; /* unicode zero width space character */
}

#download-cleartext {
    color: #af0303;
}

button {
    font-weight:bold;
    cursor: pointer;
}

#salt-is-missing {
    display: none;
    color: #dc2e2e;
    background-color: #fff799;
    margin-bottom: 1em;
    padding: 0.3em;
    font-weight: bold;
    text-align: center;
}

textarea {
  background: none repeat scroll 0 0 rgba(0, 0, 0, 0.07);
  border-radius: 6px;
  border-style: none solid solid none;
  border-width: medium 1px 1px medium;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.12) inset;
  color: #9b9b9b;
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size: 1em;
  line-height: 1.4em;
  padding: 0.5em;
  transition: background-color 0.2s ease 0s;
}

textarea:focus {
    background: none repeat scroll 0 0 rgb(194, 196, 198);
    color: #32393f;
    outline-width: 0;
}

-webkit-input-placeholder,
textarea::placeholder {
    font-weight: bold;
    color: azure;
    opacity: 0.5;
    font-family: Arial, Helvetica, sans-serif;
}

textarea:focus::placeholder {
    color: transparent;
}

.page-load {
    animation: fadein 1000ms;
}

@keyframes fadein {
    from { opacity: 0}
    to   { opacity: 1}
}

#login-dialog {
    display: flex;
    height: 100%;
    align-items: center;
    justify-content: center;
    color: rgb(194, 196, 198);
    flex-direction: column;
}

.input-group {
    position: relative;
    height: 1.3em;
    width: 300px;
    margin-bottom: 2em;
}

.ig-text {
    position: absolute;
    width: 100%;
    height: 100%;
    background-color: transparent;
    border: none;
    outline: none;
    color: rgb(194, 196, 198);
    z-index: 2;
    box-sizing: border-box;
    border-bottom: 2px solid #696969;
}

.ig-text ~ .ig-helpers {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 2px;
    background-color: rgb(194, 196, 198);
    visibility: hidden;
    transform: scaleX(0);
    transition: all 0.3s ease-in-out 0s;
}

.ig-text:focus ~ .ig-helpers {
    visibility: visible;
    transform: scaleX(1);
}

.ig-label {
    position: absolute;
    top: 0;
    width: 100%;
    text-align: center;
    transition: transform 0.3s;
}

.ig-text:invalid {
    box-shadow: none;
}

.ig-text:focus ~ .ig-label,
.ig-text:valid ~ .ig-label {
    transform: translate(0, -16px) scale(.9);
    font-size: 0.8em;
}

#login-dialog {
    display: none;
}

.require-login .main-container {
    display: none;
}

.require-login #login-dialog {
    display: flex;
}

.require-login #logout-btn {
    display: none;
}

.enable-external-actions .external.action {
    display: initial;
}

.external.action {
    display: none;
}

.actions {
    text-align: right;
}

.action-bar {
    width: 100%;
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    flex-wrap: wrap;
    margin-bottom: 0.5em;
}

button.action {
    margin-bottom: 0.2em;
}

.action-bar .title {
    font-weight: bold;
    color: #af9f88;
    text-shadow: 0 0 33px black;
    font-size: 1.3em;
    margin-right: 0.2em;
}

#error-bar {
    line-height: 1.5em;
    background-color: #ea2e2e;
    color: black;
    text-align: center;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    cursor: pointer;
}

#error-bar:not(:empty)::after {
    content: "x";
    position: absolute;
    right: 0.5em;
    font-family: monospace;
    font-weight: bold;
}

@keyframes bounce {
    0%, 20%, 53%, 80%, 100% {
        transition-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);
        transform: translate3d(0,0,0);
    }
    40%, 43% {
        transition-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
        transform: translate3d(0, 30px, 0);
    }
    70% {
        transition-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);
        transform: translate3d(0, 15px, 0);
    }
    90% {
        transform: translate3d(0,4px,0);
    }
}

.bump {
    animation: bounce 1s ;
    transform-origin: center bottom;
}


#overlay {
    display: flex;
    height: 100%;
    background-color: rgba(159, 159, 187, 0.56);
    position: fixed;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    justify-content: center;
    align-items: center;
}

@keyframes spinner-animation {
  to {transform: rotate(360deg);}
}

#spinner {
  box-sizing: border-box;
  width: 4em;
  height: 4em;
  border-radius: 50%;
  border: 2px solid #ccc;
  border-top-color: #333;
  animation: spinner-animation .6s linear infinite;
}

#overlay.is-hidden {
    display: none;
}


</style>
</head>
<body spellcheck="false" class="require-login enable-external-actions" onload="onPageLoaded()">

<div id="salt-is-missing">
    You didn't set a "salt". Open the file and read the instructions near
    PBKDF2_SALT or pass the query parameter "salt".
</div>

<div id="login-dialog" class="page-load">
    <div class="input-group">
        <input id="secret" type="password"
            class="ig-text"
            required=""
            autocomplete="new-password" />
        <i class="ig-helpers" ></i>
        <label class="ig-label" for="secret">Password</label>
    </div>
    <div class="input-group">
        <input id="confirm-secret" type="password"
            class="ig-text"
            required=""
            autocomplete="new-password" />
        <i class="ig-helpers" ></i>
        <label class="ig-label" for="confirm-secret">Confirm Password</label>
    </div>
    <div class="input-group" >
        <input id="username" type="text"
            title="You can omit the username, but then you won't be able to access external services (e.g. to upload/sync your files)"
            class="ig-text"
            required=""
            autocomplete="off" />
        <i class="ig-helpers"></i>
        <label class="ig-label" for="username">Username</label>
    </div>
    <button id="login-btn" type="submit" disabled="disabled" autocomplete="off">Unlock</button>
</div>

<button id="logout-btn">Logout</button>

<div class="main-container">

<div class="plaintext-container">
    <p class="action-bar"><label class="title">Cleartext</label> <button id="download-cleartext" class="action">⬇ download</button></p>
    <textarea id="plaintext" class="change-ciphertext" autocomplete="off" placeholder="Click here to type some text to encrypt"></textarea>
</div>

<div class="ciphertext-container">
    <p class="action-bar">
    <label class="title">Ciphertext</label>
    <span class="actions">
    <button id="reload-ciphertext" class="external action">⟳ reload</button>
    <button id="upload-ciphertext" class="external action">⬆ upload</button>
    <button id="download-ciphertext" class="action"> ⬇ download</button>
    </span>
    </p>
    <p id="ciphertext-error-bar"></p>
    <textarea id="ciphertext" autocomplete="off" placeholder="Click here to paste some text to decrypt"></textarea>
</div>

<!-- invisible anchor used to trigger the download dialog -->
<a id ="download-dialog-anchor" href="" style="display:none"></a>

</div>

<p id="error-bar"></p>
<div id="overlay" class="is-hidden"><div id="spinner"></div></div>

<script id="the-script">

    function stringToUint8Array(text) {
        return new TextEncoder().encode(text);
    }

    function bufToString(arr) {
        return new TextDecoder().decode(arr);
    }

    function atob_exceptional(ascii) {
        try { return atob(ascii); }
        catch (e) { throw new Base64DecodeError(); }
    }

    class Base64DecodeError extends Error {};

    function u_atob(ascii) {
        return Uint8Array.from(atob_exceptional(ascii), c => c.charCodeAt(0));
    }

    function u_btoa(buffer) {
        var binary = [];
        var bytes = new Uint8Array(buffer);
        for (var i = 0, il = bytes.byteLength; i < il; i++) {
            binary.push(String.fromCharCode(bytes[i]));
        }
        return btoa(binary.join(''));
    }

    function bufToHex(buffer) {
        return new Uint8Array(buffer).reduce((a, b) => a + ('0' + b.toString(16)).slice(-2), '');
    }

    function getRandomHexString(length) {
        let array = new Uint8Array(Math.ceil(length/2));
        window.crypto.getRandomValues(array);
        return bufToHex(array).slice(0, length);
    }

    async function willGenerateKeyPBKDF2(secret) {
        if (!secret) {
            // Firefox doesn't allow it, Chrome does. Let's make it consistent.
            throw new GenerateKeyError('Cannot generate a key using an empty secret');
        }

        try {
            return await crypto.subtle.importKey(
                'raw',
                stringToUint8Array(secret),
                { name: 'PBKDF2' },
                false, // whether the key can be extracted or not
                [ 'deriveKey' ]
            );
        } catch (e) {
            throw new GenerateKeyError(e.message || e.name);
        }
    }

    class GenerateKeyError extends Error {};

    async function willDeriveKey(baseKey, {saltString, iterations}) {
        try {
            return await crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: stringToUint8Array(saltString),
                    iterations: iterations,
                    hash: 'SHA-256'
                },
                baseKey,
                { "name": 'AES-GCM', "length": 256 },
                false, // whether the key can be extracted or not
                [ "encrypt", "decrypt" ]
            );
        }
        catch (e) {
            throw new DeriveKeyError(e.message || e.name);
        }
    }

    class DeriveKeyError extends Error {};

    /**
     * Encrypt text using 256 AES in GCM mode, deriving the key with PBKDF2.
     *
     * @param string plaintext the text to encrypt
     * @param string secret the secret to use to derive the key with PBKDF2
     * @param array optionsPBKDF2
     *              - string salt use it to prevent dictionary attacks
     *              - number iterations the number of PBKDF2 iterations to derive the key
     * @param arrayBuffer b_iv a nonce to use in AES-GCM
     * @return Promise that will resolve to our encrypted box format.
     *
     * The encrypted box is formed by 3 base64 encoded parts (additional data,
     * iv, ciphertext <concat> tag), separated by a dot.
     *
     * The additional data is a JSON object with the salt and iterations used
     * to derive the key with PBKDF2.
     *
     * >>> willEncryptPlaintext(
     * >>>     'the text to encrypt',
     * >>>     'your strong secret',
     * >>>     {
     * >>>         salt: 'string to make your key unique even if your secret was more common than you thinked',
     * >>>         iterations: 60000,
     * >>>     },
     * >>>     new Uint8Array([0,1,...,11]) // 96 bit nonce
     * >>> ).then(function (result) {
     * >>>     console.log(result); // abc.def.ghi
     * >>> });
     */
    async function willEncryptPlaintext(plaintext, secret, optionsPBKDF2, b_iv) {
        let baseKey = await willGenerateKeyPBKDF2(secret)
        let derivedKey = await willDeriveKey(baseKey, optionsPBKDF2);
        let b_ad = stringToUint8Array(JSON.stringify(optionsPBKDF2));
        let b_enc = await crypto.subtle.encrypt(
            {
                name: 'AES-GCM',
                iv: b_iv,
                additionalData: b_ad,
            },
            derivedKey,
            stringToUint8Array(plaintext)
        );

        return [
            u_btoa(b_ad),
            u_btoa(b_iv),
            u_btoa(b_enc), // ciphertext | tag
        ].join('.');
    }

    function json_parse_exceptional(string) {
        try { return JSON.parse(string); }
        catch (e) { throw new JSONDecodeError(); }
    }

    class JSONDecodeError extends Error {};

    function crypto_subtle_decrypt_exceptional(algorithm, key, data) {
        return crypto.subtle.decrypt(algorithm, key, data)
        .catch(e => { throw new SubtleDecryptError; });
    }

    class SubtleDecryptError extends Error {};

    /**
     * Decrypt data using 256 AES in GCM mode, deriving the key with PBKDF2.
     *
     * @param string ciphertext the text to decrypt, as produced by willEncryptPlaintext
     * @param string secret the secret to use to derive the key with PBKDF2
     *
     * @return Promise that will resolve to an object with format {plaintext,
     * additionalData, iv}
     *
     */
    async function willDecryptCiphertext(encryptedBox, secret) {
        let [b64_ad = '', b64_iv = '', b64_enc = ''] = encryptedBox.split('.');
        let [b_ad, b_iv, b_enc] = [b64_ad, b64_iv, b64_enc].map(u_atob);
        let additionalData = json_parse_exceptional(bufToString(b_ad));

        let optionsPBKDF2 = {
            salt: additionalData.salt || '',
            iterations: additionalData.iterations || 1,
        };

        let baseKey = await willGenerateKeyPBKDF2(secret)
        let derivedKey = await willDeriveKey(baseKey, optionsPBKDF2);
        let b_dec = await crypto_subtle_decrypt_exceptional(
            {
                name: 'AES-GCM',
                iv: b_iv,
                additionalData: b_ad,
            },
            derivedKey,
            b_enc
        );

        return {
            plaintext: bufToString(b_dec),
            additionalData,
            iv: b_iv,
        };
    }

    function willRequestEncryption(plaintext) {
        if (!plaintext) return '';
        let secret = getSecret();
        let b_iv = window.crypto.getRandomValues(new Uint8Array(16));
        let optionsPBKDF2 = {
            salt: getPBKDF2Salt(),
            iterations: getPBKDF2Iterations(),
        };

        return willEncryptPlaintext(plaintext, secret, optionsPBKDF2, b_iv);
    }

    function triggerDownloadDialog(blob, filename) {
        const url = window.URL.createObjectURL(blob);
        const anchor = getDownloadDialogAnchorDOMElement();

        anchor.href = url;
        anchor.download = filename;
        anchor.click();
        window.URL.revokeObjectURL(url);
    }

    /**
     * Return a string with the format YYYY-MM-DD_HHMMSS
     */
    function makeDateTimePrefix(date) {
        const isoDateTime = date.toISOString();
        const datePart = isoDateTime.split('T')[0];
        const timePart = isoDateTime.split('T')[1].split('.')[0];

        return datePart + '_' + timePart.replace(/:/g, '');
    }

    let getPlaintextDOMElement = () => document.getElementById('plaintext');
    let getPlaintext = () => getPlaintextDOMElement().value;
    let setPlaintext = value => getPlaintextDOMElement().value = value;

    let getCiphertextDOMElement = () => document.getElementById('ciphertext');
    let getCiphertext = () => getCiphertextDOMElement().value;
    let setCiphertext = value => getCiphertextDOMElement().value = value;

    let getSecretDOMElement = () => document.getElementById('secret');
    let getSecret = () => getSecretDOMElement().value;

    let getPBKDF2Salt = () => PBKDF2_SALT;
    let getPBKDF2Iterations = () => PBKDF2_ITERATIONS;

    let getDownloadCleartextButtonDOMElement = () => document.getElementById('download-cleartext');
    let getDownloadCiphertextButtonDOMElement = () => document.getElementById('download-ciphertext');
    let getDownloadDialogAnchorDOMElement = () => document.getElementById('download-dialog-anchor');

    let getUploadCiphertextButtonDOMElement = () => document.getElementById('upload-ciphertext');
    let getReloadCiphertextButtonDOMElement = () => document.getElementById('reload-ciphertext');

    let getLoginButtonDOMElement = () => document.getElementById('login-btn');
    let getLogoutButtonDOMElement = () => document.getElementById('logout-btn');
    let getMainContainerDOMElement = () => document.getElementById('main-container');

    let getSaltIsMissingDOMElement = () => document.getElementById('salt-is-missing');

    let getUsernameDOMElement = () => document.getElementById('username');
    let getUsername = () => getUsernameDOMElement().value;
    let getConfirmSecretDOMElement = () => document.getElementById('confirm-secret');
    let getConfirmSecret = () => getConfirmSecretDOMElement().value;

    let getOVerlayDOMElement = () => document.getElementById('overlay');

    let getErrorBarDOMElement = () => document.getElementById('error-bar');
    let getCiphertextErrorBarDOMElement = () => document.getElementById('ciphertext-error-bar');

    const pushErrorToDisplayQueue = (e) => {
        const errorMessage = e.message || e.name || 'Unknown error';
        if (errorMessage != ERRORS_QUEUE.slice(-1)[0]) {
            ERRORS_QUEUE.push(errorMessage);
        }
        displayErrorBanner();
    };

    const discardLatestError = () => {
        ERRORS_QUEUE.pop()
        displayErrorBanner();
    }

    const displayErrorBanner = () => {
        const errorMessage = ERRORS_QUEUE.slice(-1)[0];
        getErrorBarDOMElement().classList.remove('bump');
        setTimeout(() => {
            getErrorBarDOMElement().innerText = errorMessage || '';
            getErrorBarDOMElement().classList.add('bump');
        }, 10);
    }

    let toggleOverlay = (isVisible) => {
        getOVerlayDOMElement().classList.toggle('is-hidden', Boolean(!isVisible));
    }

    let ciphertextHasError = () => getCiphertextDOMElement().classList.contains('has-error');
    let setCiphertextError = (errorMessage) => {
        const hasError = Boolean(errorMessage.trim());
        getCiphertextDOMElement().classList.toggle('has-error', hasError);
        getCiphertextErrorBarDOMElement().innerText = errorMessage;
    }

    let encryptPlaintextAndSetCiphertext = async function() {
        try {
            let ciphertext = await willRequestEncryption(getPlaintext());
            setCiphertext(ciphertext);
            setCiphertextError('');
        } catch (e) {
            pushErrorToDisplayQueue(e);
        }
    };

    getDOMElementsWhoseValuesAreUsedToEncrypt = () => document.querySelectorAll('.change-ciphertext');

    async function updatePlaintextFromCiphertext() {
        setCiphertextError('');
        try {
            const secret = getSecret();
            const ciphertext = getCiphertext();
            let plaintext = '';

            if (ciphertext) {
                const result = await willDecryptCiphertext(ciphertext, secret);
                plaintext = result.plaintext;
            }

            setPlaintext(plaintext);
        } catch (e) {
            if (!(e instanceof JSONDecodeError
                || e instanceof Base64DecodeError
                || e instanceof SubtleDecryptError)) {
                console.error(e);
            }
            setCiphertextError('Cannot decrypt, most likely the ciphertext is not correct: focus the cleartext to refresh the ciphertext');
        };
    }

    async function onDownloadCiphertextButtonClicked(ev) {
        ev.preventDefault();

        let encryptedBox = await willRequestEncryption(getPlaintext());
        const blob = new Blob([encryptedBox], {type: "plain/text"});
        const filename = makeDateTimePrefix(new Date()) + '_encrypted_vanillacrypto.txt';

        triggerDownloadDialog(blob, filename);
    }

    function onDownloadCleartextButtonClicked(ev) {
        ev.preventDefault();

        const blob = new Blob([getPlaintext()], {type: "plain/text"});
        const filename = makeDateTimePrefix(new Date()) + '_cleartext_vanillacrypto.txt';

        triggerDownloadDialog(blob, filename);
    }

    async function onReloadCiphertextButtonClicked(ev) {
        ev.preventDefault();
        toggleOverlay(true);
        try {
            await reloadFile();
            toggleOverlay(false);
        } catch (e) {
            pushErrorToDisplayQueue(e);
            toggleOverlay(false);
        }
    }

    async function _willGetAuthToken() {
        try {
            // user exists, we've got a challenge to decrypt
            let challenge = (await willRequestChallenge()).content.challenge
            return (await willAnswerChallenge(challenge)).content.token;
        } catch (e) {
            if (e instanceof UserDoesNotExistError) {
                if (!window.confirm('No user found with that username, would you like to create it?')) {
                    throw new Error('User refused to create an account');
                }

                return (await willCreateNewUser()).content.token;
            } else {
                throw e;
            }
        }
    }

    /**
     * Retrieve an authorization token.
     *
     * The token is cached unless the option {refresh: true} is provided.
     * Use fetchJSONWithRetryOnAuthExpired() to automatically refresh it.
     */
    let willGetAuthToken = (() => {
        let token = null;

        return async function(options) {
            if (!token || (options || {}).refresh) {
                token = await _willGetAuthToken();
            }
            return token;
        }
    })();

    async function willRequestChallenge() {
        let url = new URL(STORE_URL + '/user/auth/request-challenge');
        url.searchParams.append('username', getUsername());

        let parsedResponse = await fetchJSON(url.href);

        if (parsedResponse.error) {
            if (parsedResponse.error.code === 1005) {
                throw new UserDoesNotExistError();
            }
            throw new CannotRequestChallengeError(parsedResponse.error);
        }

        return parsedResponse;
    }

    class UserDoesNotExistError extends Error {}

    async function willAnswerChallenge(challenge) {
        let answerBox = await willDecryptCiphertext(challenge, getSecret());
        let answer = answerBox.plaintext;

        let url = new URL(STORE_URL + '/user/auth/answer-challenge');
        let parsedResponse = await fetchJSONWithRetryOnAuthExpired(url.href, {
            method: 'POST',
            body: JSON.stringify({
                username: getUsername(),
                answer,
            }),
        });

        if (parsedResponse.error) {
            throw new CannotAnswerChallengeError(parsedResponse.error);
        }

        return parsedResponse;
    }

    async function willCreateNewUser() {
        let h_answer = getRandomHexString(32);
        let url = new URL(STORE_URL + '/user/');
        let parsedResponse = await fetchJSON(url.href, {
            method: 'POST',
            body: JSON.stringify({
                username: getUsername(),
                challenge: await willRequestEncryption(h_answer),
                answer: h_answer,
            }),
        });

        if (parsedResponse.error) {
            throw new CannotCreateNewUserError(parsedResponse.error);
        }

        return parsedResponse;
    }

    class CannotCreateNewUserError extends Error {
        constructor(jsonError) {
            super();
            this.message = 'Couldn\'t create the user. Server response was: ' +
            '[' + jsonError.code + '] ' + jsonError.message;
        }
    }

    class CannotRequestChallengeError extends Error {
        constructor(jsonError) {
            super();
            this.message = 'Couldn\'t start authentication. Server response was: ' +
            '[' + jsonError.code + '] ' + jsonError.message;
        }
    }

    class CannotAnswerChallengeError extends Error {
        constructor(jsonError) {
            super();
            this.message = 'Couldn\'t authenticate. Server response was: ' +
            '[' + jsonError.code + '] ' + jsonError.message;
        }
    }

    const getFilenameOrDefault = (() => {
        let _filename = null;
        return ((defaultFilename) => {
            if (!_filename) {
                _filename = defaultFilename || getRandomHexString(32);
            }
            return _filename;
        });
    })();

    async function onUploadCiphertextButtonClicked(ev) {
        ev.preventDefault();

        // XXX this is ok as long as we support just a single file
        let filename = getFilenameOrDefault();

        toggleOverlay(true);

        try {
            let ciphertext = await willRequestEncryption(getPlaintext()); // XXX this way we upload something different from what the user sees !!!!
            let uploadUrl = await willRequestUploadUrl(filename);
            if (uploadUrl.slice(0, TRUSTED_UPLOAD_BASE_URL.length) !== TRUSTED_UPLOAD_BASE_URL) {
                throw new Error('The server proposed to upload the file to an untrusted url!');
            }
            await willUploadCiphertext(uploadUrl, ciphertext);

            let objectUrl = uploadUrl.replace(/\?.*$/, '');
            let uploadedContent = await willDownload(objectUrl);
            if (uploadedContent !== ciphertext) {
                throw new Error('The uploaded file does not match the original file');
            }
            console.log('Cool, the file was uploaded correctly!');
        } catch (e) {
            if (e instanceof UploadCiphertextError
                || e instanceof CannotRequestUploadUrlError) {
                pushErrorToDisplayQueue(e);
            } else {
                console.error('Error uploading the ciphertext', e);
                pushErrorToDisplayQueue(new Error('Error uploading the ciphertext'));
            }
        }

        toggleOverlay(false);
    };

    async function reloadFile() {
        try {
            const files = await willGetFilesList();
            let ciphertext = '';
            if (files.length > 0) {
                getFilenameOrDefault(files[0].content.filename);
                ciphertext = await willDownload(files[0].links.read.href);
            }
            setCiphertext(ciphertext);
            updatePlaintextFromCiphertext();
        } catch (e) {
            if (e instanceof CannotRetrieveFilesListError) {
                throw e;
            } else if (e instanceof DownloadError) {
                throw e;
            } else {
                console.error(e);
                throw new Error('An error occurred while reloading the ciphertext');
            }
        }
    }

    async function willRequestUploadUrl(filename) {
        let href = STORE_URL + '/file/request-upload-url';
        let token = await willGetAuthToken();
        let parsedResponse = await fetchJSONWithRetryOnAuthExpired(href, {
            method: 'POST',
            body: JSON.stringify({
                jwt: token,
                filename: filename,
            }),
        })

        if (parsedResponse.error) {
            throw new CannotRequestUploadUrlError(parsedResponse.error);
        }

        return parsedResponse.links.upload_url.href;
    }

    class CannotRequestUploadUrlError extends Error {
        constructor(jsonError) {
            super();
            this.message = 'Cannot get the url to upload to. Server response was: ' +
            '[' + jsonError.code + '] ' + jsonError.message;
        }
    }

    async function willUploadCiphertext(uploadUrl, ciphertext) {
        try {
            let href = uploadUrl;
            let response = await fetchOrThrow(href, {
                headers: {
                    'Cache-Control': 'None',
                    'Expect': '100-continue',
                    'Content-Encoding': 'utf-8',
                    'Content-Type': 'text/plain',
                    // XXX ... no md5 in crypto subtle, so we can't rely on it.
                    // We'll have to download the file and verify his content later
                    // 'Content-MD5': 'application/json',
                },
                method: 'PUT',
                body: ciphertext,
            });

            if (!response.ok) {
                throw new UploadCiphertextError('Couldn\'t upload the ciphertext, response status was: ' + statusText);
            }

            return response;
        } catch (e) {
            if (e instanceof FetchUnexpectedError
                || e instanceof FetchRequestTimedOutError) {
                throw new UploadCiphertextError(e.message);
            } else {
                throw e;
            }
        }
    }

    class UploadCiphertextError extends Error {};

    async function willDownload(href) {
        let response = await fetchOrThrow(href, {
            mode: 'cors',
            cache: 'no-store',
            referrerPolicy: 'no-referrer',
        });

        if (response.ok) {
            return response.text();
        } else {
            throw new DownloadError(response.statusText);
        }
    }

    class DownloadError extends Error {
        constructor(statusText) {
            super();
            this.message = 'Couldn\'t download the file. Server response was: ' + statusText;
        }
    }

    async function willGetFilesList() {
        let url = new URL(STORE_URL + '/files/')
        url.searchParams.append('jwt', await willGetAuthToken());

        let jsonResponse = await fetchJSONWithRetryOnAuthExpired(url.href);
        if (jsonResponse.error) { throw new CannotRetrieveFilesListError(jsonResponse.error); }
        return jsonResponse.content;
    }

    async function fetchJSONWithRetryOnAuthExpired(href, options) {
        let response = await fetchJSON(href, options);
        if (response.error && response.error.code === 1007) {
            // 1007 means "token expired"
            await willGetAuthToken({refresh: true});
            response = await fetchJSON(href, options);
        }
        return response;
    }

    class FetchUnexpectedError extends Error {
        constructor(orig) {
            super();
            this.message = "Cannot fetch an external resource: check your internet connection or configuration";
            this.details = orig;
        }
    }
    class FetchRequestTimedOutError extends Error {
        constructor() {
            super();
            this.message = "The request is taking too long to complete";
        }
    }
    class FetchUnexpectedFormat extends Error {
        constructor(statusText) {
            super();
            this.message = statusText;
        }
    }

    class CannotRetrieveFilesListError extends Error {
        constructor(jsonError) {
            super();
            this.message = 'Cannot retrieve the files\' list. Server response was: ' +
            '[' + jsonError.code + '] ' + jsonError.message;
        }
    }

    async function fetchOrThrow(href, options) {
        let request = fetch(href, options)
        .catch (e => { throw new FetchUnexpectedError(e); });
        let timeout = new Promise((resolve, reject) => {
            // XXX we should abort the request on timeout
            setTimeout(() => reject(new FetchRequestTimedOutError()), 15000);
        });
        return Promise.race([timeout, request]);
    }

    async function fetchJSON(href, options) {
        options = Object.assign({}, {
            headers: {},
            mode: 'cors',
            cache: 'no-store',
            referrerPolicy: 'no-referrer',
        }, options || {});

        options.headers['Content-Type'] = 'application/json';

        let response = await fetchOrThrow(href, options);

        if (response.headers.get('Content-Type') === 'application/json') {
            return response.json();
        } else {
            throw new FetchUnexpectedFormat(response.statusText);
        }
    }

    async function attemptLogin() {
        if (getConfirmSecret() !== getSecret()) {
            window.alert('The passwords don\'t match');
        } else {
            toggleOverlay(true);
            try {
                if (getUsername()) {
                    // auth, possibly ask to create the user
                    let token = await willGetAuthToken();
                    await reloadFile();
                } else {
                    document.body.classList.remove('enable-external-actions');
                }
                document.body.classList.remove('require-login');
            } catch (e) {
                pushErrorToDisplayQueue(e);
            }
            toggleOverlay(false);
        }
    }

    function onPageLoaded() {

        getErrorBarDOMElement().addEventListener('click', (ev) => discardLatestError());
        // encrypt plaintext on focus only when there are errors, otherwise with a random IV we would
        // change the ciphertext without reason
        getPlaintextDOMElement().addEventListener('focus', ev => {
            if (ciphertextHasError()) { encryptPlaintextAndSetCiphertext(); }
        });
        // redo encryption if any of the fields used to encrypt has changed
        getDOMElementsWhoseValuesAreUsedToEncrypt().forEach(elem => {
            elem.addEventListener('input', ev => encryptPlaintextAndSetCiphertext());
        });
        // redo decryption if the ciphertext has changed (or may have changed)
        ['input', 'focus'].forEach(eventType => {
            getCiphertextDOMElement().addEventListener(eventType, ev => updatePlaintextFromCiphertext())
        });

        getDownloadCiphertextButtonDOMElement().addEventListener('click', onDownloadCiphertextButtonClicked);
        getDownloadCleartextButtonDOMElement().addEventListener('click', onDownloadCleartextButtonClicked);
        getReloadCiphertextButtonDOMElement().addEventListener('click', onReloadCiphertextButtonClicked);
        getUploadCiphertextButtonDOMElement().addEventListener('click', onUploadCiphertextButtonClicked);

        if (!getPBKDF2Salt()) {
            getSaltIsMissingDOMElement().style.display = 'block';
        }

        [getSecretDOMElement(), getConfirmSecretDOMElement()].forEach((elem) => {
            let loginBtn = getLoginButtonDOMElement();

            elem.addEventListener('input', () => {
                loginBtn.disabled = getConfirmSecret() !== getSecret();
            });
        });

        getLoginButtonDOMElement().addEventListener('click', ev => attemptLogin());
        document.querySelectorAll('#login-dialog .ig-text').forEach(elem => {
            elem.addEventListener('keyup', ev => ev.key === 'Enter' && attemptLogin());
        });
        getLogoutButtonDOMElement().addEventListener('click', () => {
            document.location.reload();
        });
    }


</script>
</body>
</html>