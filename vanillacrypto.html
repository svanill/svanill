<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<script>
// Salt, it ensures that two people with the same password will generate
// different secret keys. It should be at least 8 random characters long.
const PBKDF2_SALT = new URLSearchParams(document.location.search).get('salt')
      || ''; // <== insert the salt inside the two '' on the far left
// Iteration count for PBKDF2. At least 10000. The higher the value
// the longer you'll need to wait after entering the password to
// derive the key used for encryption.
const PBKDF2_ITERATIONS = new URLSearchParams(document.location.search).get('iterations')
      || 60000;
// Url fo the service (an instance of Piggy Store) where you could optionally
// store your encrypted data
const STORE_URL = 'http://localhost:5000';
// How you want to name the file on the storage server that will hold your data.
const FILENAME = 'main';
</script>
<style>

html {
    background-color: #cad8d9;
    font-family: Verdana, Geneva, Tahoma, sans-serif;
    background: #32393F;
    height: 100%;
}

body {
    box-sizing: border-box;
    max-width: 1200px;
    padding: 1em;
    margin: 0 auto;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    height: 100%;
}

p,
input[type=checkbox] {
    margin: 0;
}

.main-container {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
}

#secret {
    box-sizing: border-box;
    padding: 0 0.2em;
    margin-right: 0.2em;
}

label {
    cursor: pointer;
}

textarea, button {
    box-sizing: border-box;
}

button {
    padding: 0 0.9em;
}

button::-moz-focus-inner,
input[type="button"]::-moz-focus-inner,
input[type="submit"]::-moz-focus-inner,
input[type="reset"]::-moz-focus-inner {
  padding: 0 !important;
  border: 0 none !important;
}

input[type=text], input[type=password] {
    padding: 0 0.3em;
}

.plaintext-container, .ciphertext-container {
    box-sizing: border-box;
    padding: 0 1em;
    display: flex;
    flex: 1 1 50%;
    flex-wrap: wrap;
}

.plaintext-container > textarea,
.ciphertext-container > textarea {
    flex: 1 1 100%;
}

#plaintext, #ciphertext {
    min-height: 70vh;
}

#ciphertext {
    font-family: Andale Mono, AndaleMono, Consolas, Monaco, monospace;
}

.error {
    color: red;
}

span.error:empty:before {
    content: "\200b"; /* unicode zero width space character */
}

#download-cleartext {
    color: #af0303;
}

button {
    font-weight:bold;
    cursor: pointer;
}

#salt-is-missing {
    display: none;
    color: #dc2e2e;
    background-color: #fff799;
    margin-bottom: 1em;
    padding: 0.3em;
    font-weight: bold;
    text-align: center;
}

textarea {
  background: none repeat scroll 0 0 rgba(0, 0, 0, 0.07);
  border-radius: 6px;
  border-style: none solid solid none;
  border-width: medium 1px 1px medium;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.12) inset;
  color: #555555;
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size: 1em;
  line-height: 1.4em;
  padding: 0.5em;
  transition: background-color 0.2s ease 0s;
}

textarea:focus {
    background: none repeat scroll 0 0 rgb(194, 196, 198);
    outline-width: 0;
}

-webkit-input-placeholder,
textarea::placeholder {
    font-weight: bold;
    color: azure;
    opacity: 0.5;
    font-family: Arial, Helvetica, sans-serif;
}

textarea:focus::placeholder {
    color: transparent;
}

.page-load {
    animation: fadein 1000ms;
}

@keyframes fadein {
    from { opacity: 0}
    to   { opacity: 1}
}

#login-dialog {
    display: flex;
    height: 100%;
    align-items: center;
    justify-content: center;
    color: white;
    flex-direction: column;
}

.input-group {
    position: relative;
    height: 1.3em;
    width: 300px;
    margin-bottom: 2em;
}

.ig-text {
    position: absolute;
    width: 100%;
    height: 100%;
    background-color: transparent;
    border: none;
    outline: none;
    color: white;
    z-index: 2;
    box-sizing: border-box;
    border-bottom: 2px solid #696969;
}

.ig-text ~ .ig-helpers {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 2px;
    background-color: white;
    visibility: hidden;
    transform: scaleX(0);
    transition: all 0.3s ease-in-out 0s;
}

.ig-text:focus ~ .ig-helpers {
    visibility: visible;
    transform: scaleX(1);
}

.ig-label {
    position: absolute;
    top: 0;
    width: 100%;
    text-align: center;
    transition: transform 0.3s;
}

.ig-text:invalid {
    box-shadow: none;
}

.ig-text:focus ~ .ig-label,
.ig-text:valid ~ .ig-label {
    transform: translate(0, -16px) scale(.9);
    font-size: 0.8em;
}

#login-dialog {
    display: none;
}

.require-login .main-container {
    display: none;
}

.require-login #login-dialog {
    display: flex;
}

#logout-btn {
    position: absolute;
    top: 0.5em;
    right: 0.5em;
}

.enable-external-actions .external-actions {
    display: flex;
}

.external-actions {
    display: none;
}

.action-bar {
    width: 100%;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

button.action {
    margin-bottom: 0.2em;
}

.action-bar .title {
    font-weight: bold;
    color: #af9f88;
    text-shadow: 0 0 33px black;
    font-size: 1.3em;
}

</style>
</head>
<body spellcheck="false" class="require-login enable-external-actions">

<div id="salt-is-missing">
    You didn't set a "salt". Open the file and read the instructions near
    PBKDF2_SALT or pass the query parameter "salt".
</div>

<div id="login-dialog" class="page-load">
    <div class="input-group">
        <input id="secret" type="password"
            class="ig-text"
            required=""
            autocomplete="new-password" />
        <i class="ig-helpers" ></i>
        <label class="ig-label" for="secret">Password</label>
    </div>
    <div class="input-group">
        <input id="confirm-secret" type="password"
            class="ig-text"
            required=""
            autocomplete="new-password" />
        <i class="ig-helpers" ></i>
        <label class="ig-label" for="confirm-secret">Confirm Password</label>
    </div>
    <div class="input-group" >
        <input id="username" type="text"
            title="You can omit the username, but then you won't be able to access external services (e.g. to upload/sync your files)"
            class="ig-text"
            required=""
            autocomplete="off" />
        <i class="ig-helpers"></i>
        <label class="ig-label" for="username">Username</label>
    </div>
    <button id="login-btn" type="submit" disabled="disabled" autocomplete="off">Unlock</button>
</div>

<div class="main-container">

<button id="logout-btn">Logout</button>

<div class="plaintext-container">
    <p class="action-bar"><label class="title">Cleartext</label> <button id="download-cleartext" class="action">⬇ download</button></p>
    <span id="plaintext-error-message" class="error"></span>
    <textarea id="plaintext" class="change-ciphertext" autocomplete="off" placeholder="Click here to type some text to encrypt"></textarea>
</div>

<div class="ciphertext-container">
    <p class="action-bar">
    <label class="title">Ciphertext</label>
    <span class="actions">
    <button id="reload-ciphertext" class="external action">⟳ reload</button>
    <button id="upload-ciphertext" class="external action">⬆ upload</button>
    <button id="download-ciphertext" class="action"> ⬇ download</button>
    </span>
    </p>
    <span id="ciphertext-error-message" class="error"></span>
    <textarea id="ciphertext" autocomplete="off" placeholder="Click here to paste some text to decrypt"></textarea>
</div>

<!-- invisible anchor used to trigger the download dialog -->
<a id ="download-dialog-anchor" href="" style="display:none"></a>

</div>

<script>

    function stringToUint8Array(text) {
        return new TextEncoder().encode(text);
    }

    function bufToString(arr) {
        return new TextDecoder().decode(arr);
    }

    function u_atob(ascii) {
        return Uint8Array.from(atob(ascii), c => c.charCodeAt(0));
    }

    function u_btoa(buffer) {
        var binary = [];
        var bytes = new Uint8Array(buffer);
        for (var i = 0, il = bytes.byteLength; i < il; i++) {
            binary.push(String.fromCharCode(bytes[i]));
        }
        return btoa(binary.join(''));
    }

    function willGenerateKeyPBKDF2(secret) {
        if (!secret) {
            // Firefox doesn't allow it, Chrome does. Let's make it consistent.
            throw new Error('Cannot generate a key with an empty secret');
        }

        return crypto.subtle.importKey(
            'raw',
            stringToUint8Array(secret),
            { name: 'PBKDF2' },
            false, // whether the key can be extracted or not
            [ 'deriveKey' ]
        );
    }

    function willDeriveKey(baseKey, {saltString, iterations}) {
        return crypto.subtle.deriveKey(
            {
                name: 'PBKDF2',
                salt: stringToUint8Array(saltString),
                iterations: iterations,
                hash: 'SHA-256'
            },
            baseKey,
            { "name": 'AES-GCM', "length": 256 },
            false, // whether the key can be extracted or not
            [ "encrypt", "decrypt" ]
        );
    }

    function willEncryptAESGCM(key, params) {
        const { iv, additionalData, plaintext } = params;
        const adAsBytes = stringToUint8Array(JSON.stringify(additionalData));

        return crypto.subtle.encrypt(
            {
                name: 'AES-GCM',
                iv,
                additionalData: adAsBytes,
            },
            key,
            stringToUint8Array(plaintext)
        ).then(enc => {
            return [
                u_btoa(adAsBytes),
                u_btoa(iv),
                u_btoa(enc), // ciphertext | tag
            ].join('.');
        });
    }

    function willDecryptAESGCM(b_key, b_iv, b_ad, b_enc) {
        return crypto.subtle.decrypt(
            {
                name: 'AES-GCM',
                iv: b_iv,
                additionalData: b_ad,
            },
            b_key,
            b_enc
        ).then(dec => ({
            plaintext: bufToString(dec),
            additionalData: JSON.parse(bufToString(b_ad)),
            iv: b_iv,
        }));
    }

    /**
     * Encrypt plaintext using 256 AES in CBC mode, deriving the key with PBKDF2.
     *
     * @param string plaintext the text to encrypt
     * @param string secret the secret to use to derive the key with PBKDF2
     * @param array optionsPBKDF2
     *              - string salt use it to prevent dictionary attacks
     *              - number iterations the number of PBKDF2 iterations to derive the key
     * @param arrayBuffer iv a nonce to use in AES-GCM
     * @return Promise that will resolve to an array with keys iv, ciphertext, whose values are hexstrings
     *
     * >>> // example
     * >>>
     * >>> willEncryptPlaintext(
     * >>>     'the text to encrypt',
     * >>>     'your strong secret',
     * >>>     {
     * >>>         salt: 'string to make your key unique even if your secret was more common than you thinked',
     * >>>         iterations: 60000,
     * >>>     },
     * >>>     new Uint8Array([0,1,...,11]) // 96 bit nonce
     * >>> ).then(function (result) {
     * >>>     console.log(result); // e.g. "<additional data as hex>.<iv as hex>.<ciphertext as hex>"
     * >>> });
     */
    function willEncryptPlaintext(plaintext, secret, optionsPBKDF2, iv) {
        return willGenerateKeyPBKDF2(secret)
        .then(function (baseKey) {
            return willDeriveKey(baseKey, optionsPBKDF2);
        })
        .then(function (derivedKey) {
            return willEncryptAESGCM(derivedKey, {
                iv,
                plaintext,
                additionalData: optionsPBKDF2
            });
        });
    }

    /**
     * Decrypt ciphertext using 256 AES in CBC mode, deriving the key with PBKDF2.
     *
     * @param string ciphertext the text to encrypt
     * @param string secret the secret to use to derive the key with PBKDF2
     * @param array optionsPBKDF2
     *              - string salt the string used alongside the secret to derive the key
     *              - number iterations the number of PBKDF2 iterations used to derive the key
     * @return Promise that will resolve to an object with key plaintext, whose value is the plaintext as string
     */
    function willDecryptCiphertext(encryptedBox, secret) {
        let [b64_ad = '', b64_iv = '', b64_enc = ''] = encryptedBox.split('.');
        let [b_ad, b_iv, b_enc] = [b64_ad, b64_iv, b64_enc].map(u_atob);
        let ad = JSON.parse(bufToString(b_ad));

        let optionsPBKDF2 = {
            salt: ad.salt || '',
            iterations: ad.iterations || '',
        };

        return willGenerateKeyPBKDF2(secret)
        .then(function (baseKey) {
            return willDeriveKey(baseKey, optionsPBKDF2);
        })
        .then(function (derivedKey) {
            return willDecryptAESGCM(derivedKey, b_iv, b_ad, b_enc);
        });
    }

    function willRequestEncryption(plaintext) {
        let secret = getSecret();
        let iv = window.crypto.getRandomValues(new Uint8Array(16));
        let optionsPBKDF2 = {
            salt: getPBKDF2Salt(),
            iterations: getPBKDF2Iterations(),
        };

        return willEncryptPlaintext(plaintext, secret, optionsPBKDF2, iv);
    }

    function willRequestDecryption() {
        let ciphertext = getCiphertext();

        if (!ciphertext) {
            return Promise.resolve({
                plaintext: '',
            });
        }

        let secret = getSecret();
        return willDecryptCiphertext(ciphertext, secret)
        .catch(function(e) {
            setCiphertextErrorMessage('The operation failed (most likely the ciphertext is not correct)');
            setPlaintextErrorMessage(
                'The plaintext does not reflect the ciphertext (focus the textarea to refresh)'
            );

            return Promise.reject(e);
        });
    }

    function triggerDownloadDialog(blob, filename) {
        const url = window.URL.createObjectURL(blob);
        const anchor = getDownloadDialogAnchorDOMElement();

        anchor.href = url;
        anchor.download = filename;
        anchor.click();
        window.URL.revokeObjectURL(url);
    }

    /**
     * Return a string with the format YYYY-MM-DD_HHMMSS
     */
    function makeDateTimePrefix(date) {
        const isoDateTime = date.toISOString();
        const datePart = isoDateTime.split('T')[0];
        const timePart = isoDateTime.split('T')[1].split('.')[0];

        return datePart + '_' + timePart.replace(/:/g, '');
    }

    let getPlaintextDOMElement = () => document.getElementById('plaintext');
    let getPlaintext = () => getPlaintextDOMElement().value;
    let setPlaintext = value => getPlaintextDOMElement().value = value;

    let getCiphertextDOMElement = () => document.getElementById('ciphertext');
    let getCiphertext = () => getCiphertextDOMElement().value;
    let setCiphertext = value => getCiphertextDOMElement().value = value;

    let getSecretDOMElement = () => document.getElementById('secret');
    let getSecret = () => getSecretDOMElement().value;

    let getPBKDF2Salt = () => PBKDF2_SALT;
    let getPBKDF2Iterations = () => PBKDF2_ITERATIONS;
    let getFilename = () => FILENAME;

    let getDownloadCleartextButtonDOMElement = () => document.getElementById('download-cleartext');
    let getDownloadCiphertextButtonDOMElement = () => document.getElementById('download-ciphertext');
    let getDownloadDialogAnchorDOMElement = () => document.getElementById('download-dialog-anchor');

    let getUploadCiphertextButtonDOMElement = () => document.getElementById('upload-ciphertext');
    let getReloadCiphertextButtonDOMElement = () => document.getElementById('reload-ciphertext');

    let getLoginButtonDOMElement = () => document.getElementById('login-btn');
    let getLogoutButtonDOMElement = () => document.getElementById('logout-btn');
    let getMainContainerDOMElement = () => document.getElementById('main-container');

    let getSaltIsMissingDOMElement = () => document.getElementById('salt-is-missing');

    let getUsernameDOMElement = () => document.getElementById('username');
    let getUsername = () => getUsernameDOMElement().value;
    let getConfirmSecretDOMElement = () => document.getElementById('confirm-secret');
    let getConfirmSecret = () => getConfirmSecretDOMElement().value;

    let getCiphertextErrorMessageDOMElement = () => document.getElementById('ciphertext-error-message');
    let getCiphertextErrorMessage = message => getCiphertextErrorMessageDOMElement().innerText.trim();
    let setCiphertextErrorMessage = message => getCiphertextErrorMessageDOMElement().innerText = message;

    let getPlaintextErrorMessageDOMElement = () => document.getElementById('plaintext-error-message');
    let getPlaintextErrorMessage = message => getPlaintextErrorMessageDOMElement().innerText.trim();
    let setPlaintextErrorMessage = message => getPlaintextErrorMessageDOMElement().innerText = message;

    let clearErrorMessages = () => {
        setCiphertextErrorMessage('');
        setPlaintextErrorMessage('');
    };

    let hasErrors = () => Boolean(getPlaintextErrorMessage() || getCiphertextErrorMessage());

    // encrypt on focus only when there are errors, otherwise with a random IV we would
    // change the ciphertext without reason
    getPlaintextDOMElement().addEventListener('focus', ev => {
        if (hasErrors()) {
            clearErrorMessages();
            willRequestEncryption(getPlaintext())
            .then(setCiphertext);
        }
    });

    getDOMElementsWhoseValuesAreUsedToEncrypt = () => document.querySelectorAll('.change-ciphertext');

    // redo encryption if any of the fields used to encrypt has changed
    getDOMElementsWhoseValuesAreUsedToEncrypt().forEach(elem => {
        let eventType = 'input';

        if (elem.type === 'checkbox') {
            eventType = 'change';
        }

        elem.addEventListener(eventType, ev => {
            clearErrorMessages();
            willRequestEncryption(getPlaintext())
            .then(setCiphertext);
        });
    });

    function updatePlaintextFromCiphertext() {
        clearErrorMessages();
        willRequestDecryption()
        .then(function (result) {
            setPlaintext(result.plaintext);
        }).catch(e => {
            console.error('cannot decode ciphertext', e);
        });
    }

    // redo decryption if the ciphertext has changed (or may have changed)
    ['input', 'focus'].forEach(eventType => {
        getCiphertextDOMElement().addEventListener(eventType, ev => updatePlaintextFromCiphertext())
    });

    getDownloadCiphertextButtonDOMElement().addEventListener('click', ev => {
        ev.preventDefault();

        willRequestEncryption(getPlaintext())
        .then(encryptedBox => {
            const blob = new Blob([encryptedBox], {type: "plain/text"});
            const filename = makeDateTimePrefix(new Date()) + '_encrypted_vanillacrypto.txt';

            triggerDownloadDialog(blob, filename);
        });
    });

    getDownloadCleartextButtonDOMElement().addEventListener('click', ev => {
        ev.preventDefault();

        const blob = new Blob([getPlaintext()], {type: "plain/text"});
        const filename = makeDateTimePrefix(new Date()) + '_cleartext_vanillacrypto.txt';

        triggerDownloadDialog(blob, filename);
    });

    getReloadCiphertextButtonDOMElement().addEventListener('click', async function(ev) {
        ev.preventDefault();
        try {
            let ciphertext = await willGetFirstFileContent();
            setCiphertext(ciphertext);
            updatePlaintextFromCiphertext();
        } catch (e) {
            console.error(e);
        }
    });

    async function _willGetAuthToken() {
        let token = null;
        let url = new URL(STORE_URL + '/user/auth/request-challenge');
        url.searchParams.append('username', getUsername());

        let parsedResponse = await fetchJSON(url.href);

        let finalResponse = null;

        if (parsedResponse.status === 401) {
            // user does not exist
            if (!window.confirm('No user found with that username, would you like to create it?')) {
                throw new Error('User refused to create an account');
            }

            finalResponse = await willCreateNewUser();
        } else if (parsedResponse.status === 200) {
            // user exists, we've got a challenge to decrypt
            let challenge = parsedResponse.content.challenge
            finalResponse = await willAnswerChallenge(challenge);

        } else {
            throw new Error(JSON.stringify(parsedResponse));
        }

        return finalResponse.content.token;
    }

    /**
     * Retrieve an authorization token.
     *
     * The token is cached unless the option {refresh: true} is provided.
     * Use fetchJSONWithRetryOnAuthExpired() to automatically refresh it.
     */
    let willGetAuthToken = (() => {
        let token = null;

        return async function(options) {
            if (!token || (options || {}).refresh) {
                token = await _willGetAuthToken();
            }
            return token;
        }
    })();

    async function willAnswerChallenge(challenge) {
        let answerBox = await willDecryptCiphertext(challenge, getSecret());
        let answer = answerBox.plaintext;

        let url = new URL(STORE_URL + '/user/auth/answer-challenge');
        return fetchJSONWithRetryOnAuthExpired(url.href, {
            method: 'POST',
            body: JSON.stringify({
                username: getUsername(),
                answer,
            }),
        });
    }

    async function willCreateNewUser() {
        // create a 32 char length random hex string
        let b_answer = window.crypto.getRandomValues(new Uint8Array(16));
        let h_answer = Array.prototype.map.call(b_answer, x => ('00' + x.toString(16)).slice(-2)).join('');

        let url = new URL(STORE_URL + '/user/');
        return fetchJSON(url.href, {
            method: 'POST',
            body: JSON.stringify({
                username: getUsername(),
                challenge: await willRequestEncryption(h_answer),
                answer: h_answer,
            }),
        });
    }

    getUploadCiphertextButtonDOMElement().addEventListener('click', async function(ev) {
        ev.preventDefault();

        let filename = getFilename();

        try {
            let ciphertext = await willRequestEncryption(getPlaintext()); // XXX this way we upload something different from what the user sees !!!!
            let uploadUrl = await willRequestUploadUrl(filename);
            let objectUrl = uploadUrl.replace(/\?.*$/, ''); // XXX this is not safe probably
            await willUploadCiphertext(uploadUrl, ciphertext);
            let uploadedContent = await willDownload(objectUrl);
            if (uploadedContent !== ciphertext) {
                throw new Error('The uploaded file does not match the original file');
            }
            console.log('Cool, the file was uploaded correctly!');
        } catch (e) {
            console.error('An error arised', e);
        }
    });

    async function willRequestUploadUrl(filename) {
        let href = STORE_URL + '/file/request-upload-url';
        let token = await willGetAuthToken();

        return fetchJSONWithRetryOnAuthExpired(href, {
            method: 'POST',
            body: JSON.stringify({
                jwt: token,
                filename: filename,
            }),
        })
        .then(jsonResponse => jsonResponse.links.upload_url.href);
    }

    async function willUploadCiphertext(uploadUrl, ciphertext) {
        let href = uploadUrl;
        return fetch(href, {
            headers: {
                'Cache-Control': 'None',
                'Expect': '100-continue',
                'Content-Encoding': 'utf-8',
                'Content-Type': 'text/plain',
                // XXX ... no md5 in crypto subtle, so we can't rely on it.
                // We'll have to download the file and verify his content later
                // 'Content-MD5': 'application/json',
            },
            method: 'PUT',
            body: ciphertext,
        });
    }

    function willDownload(href) {
        return fetch(href, {
            mode: 'cors',
            cache: 'no-store',
            referrerPolicy: 'no-referrer',
        })
        .then(response => {
            if (response.ok) {
                return response.text();
            } else {
                return Promise.reject(response.statusText);
            }
        });
    }

    async function willGetFilesList() {
        let url = new URL(STORE_URL + '/files/')
        url.searchParams.append('jwt', await willGetAuthToken());

        let jsonResponse = await fetchJSONWithRetryOnAuthExpired(url.href);
        return jsonResponse.content;
    }

    async function willGetFirstFileContent() {
        let files = await willGetFilesList();
        return files.length > 0 ? await willDownload(files[0].links.read.href) : '';
    }

    async function fetchJSONWithRetryOnAuthExpired(href, options) {
        let response = await fetchJSON(href, options);
        if (response.error && response.error.code === 1007) {
            // 1007 means "token expired"
            await willGetAuthToken({refresh: true});
            response = await fetchJSON(href, options);
        }
        return response;
    }

    async function fetchJSON(href, options) {
        options = Object.assign({}, {
            headers: {},
            mode: 'cors',
            cache: 'no-store',
            referrerPolicy: 'no-referrer',
        }, options || {});

        options.headers['Content-Type'] = 'application/json';

        let response = await fetch(href, options);

        if (response.headers.get('Content-Type') === 'application/json') {
            return response.json();
        } else {
            throw new Error(response.statusText);
        }
    }

    if (!getPBKDF2Salt()) {
        getSaltIsMissingDOMElement().style.display = 'block';
    }


    [getSecretDOMElement(), getConfirmSecretDOMElement()].forEach((elem) => {
        let loginBtn = getLoginButtonDOMElement();

        elem.addEventListener('input', () => {
            loginBtn.disabled = getConfirmSecret() !== getSecret();
        });
    });

    getLoginButtonDOMElement().addEventListener('click', () => {
        if (getConfirmSecret() !== getSecret()) {
            window.alert('The passwords don\'t match');
        } else {
            try {
                if (getUsername()) {
                    // auth, possibly ask to create the user
                    let token = await _willGetAuthToken();
                } else {
                    document.body.classList.remove('enable-external-actions');
                }
                document.body.classList.remove('require-login');
            } catch (e) {
                displayError(e);
            }
        }
    });

    getLogoutButtonDOMElement().addEventListener('click', () => {
        document.location.reload();
    });



</script>
</body>
</html>