<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<script>
// Salt, it ensures that two people with the same password will generate
// different secret keys. It should be at least 8 random characters long.
const PBKDF2_SALT = new URLSearchParams(document.location.search).get('salt')
      || ''; // <== insert the salt inside the two '' on the far left
// Iteration count for PBKDF2. At least 10000. The higher the value
// the longer you'll need to wait after entering the password to
// derive the key used for encryption.
const PBKDF2_ITERATIONS = new URLSearchParams(document.location.search).get('iterations')
      || 60000;
// Url fo the service (an instance of Piggy Store) where you could optionally
// store your encrypted data
const STORE_URL = 'http://localhost:5000';
// How you want to name the file on the storage server that will hold your data.
const FILENAME = 'main';
</script>
<style>

html {
    background-color: #cad8d9;
}

body {
    box-sizing: border-box;
    width: 100%;
    padding: 1em;
    margin: 0 auto;
}

input[type=checkbox] {
    margin: 0;
}

fieldset {
    margin: 0;
    padding: 1em;
    border: 0;
}

legend {
    margin: 0;
    padding: 0;
    font-weight: bold;
}

.main-container {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
}

.informations {
    display: block;
    flex: 1 1 100%;
    margin-top: 1em;
}

.secret-container {
    display: flex;
    flex: 1 1 100%;
    flex-wrap: wrap;
    justify-content: center;
}

#secret {
    box-sizing: border-box;
    padding: 0 0.2em;
    width: 30em;
    margin-right: 0.2em;
}

label {
    cursor: pointer;
}

#show-secret {
    display: none;
}

#show-secret:checked + label{
    color: red;
}

textarea, button {
    box-sizing: border-box;
}

input[type=text], input[type=password] {
    padding: 0 0.3em;
}

.plaintext-container, .ciphertext-container {
    display: flex;
    flex: 1 1 35%;
    flex-direction: column;
    align-items: center;
}

#plaintext, #ciphertext {
    min-height: 400px;
    width: 90%;
}

.error {
    color: red;
}

span.error:empty:before {
    content: "\200b"; /* unicode zero width space character */
}

.field-name {
    display: flex;
    flex: 0.2;
}

#download-cleartext {
    background-color: red;
}

button {
    background-color: green;
}

#salt-is-missing {
    display: none;
    color: #dc2e2e;
    background-color: #fff799;
    margin-bottom: 1em;
    padding: 0.3em;
    font-weight: bold;
    text-align: center;
}

</style>
</head>
<body spellcheck="false">

<div id="salt-is-missing">
    You didn't set a "salt". Open the file and read the instructions near
    PBKDF2_SALT or pass the query parameter "salt".
</div>

<div class="main-container">
    <div class="secret-container">
        <label>Password <input id="secret" type="password" class="change-ciphertext" /></label>
        <input
            id="show-secret"
            type="checkbox"
            onchange="document.getElementById('secret').type = this.checked ? 'text' : 'password'"
            title="Show password"
            autocomplete="off"
        />
        <label for="show-secret">üëÅ</label>
    </div>

    <div class="username-container">
        <label>Username <input id="username" type="text" value="foobar" /></label>
        <label>Confirm password <input id="confirm-secret" type="text" /></label>
    </div>

    <div class="plaintext-container">
        <h2>Plaintext</h2>
        <span id="plaintext-error-message" class="error"></span>
        <textarea id="plaintext" class="change-ciphertext" autocomplete="off"></textarea>
    </div>
    <div class="ciphertext-container">
        <h2>Ciphertext</h2>
        <span id="ciphertext-error-message" class="error"></span>
        <textarea id="ciphertext" autocomplete="off"></textarea>
    </div>

    <div class="local-actions">
        <button id="download-cleartext">Download clear text</button>
        <button id="download-ciphertext">Download encrypted</button>
        <!-- invisible anchor used to trigger the download dialog -->
        <a id ="download-dialog-anchor" href="" style="display:none"></a>
    </div>

    <div class="external-actions">
        <button id="upload-ciphertext">Save encrypted text</button>
        <button id="reload-ciphertext">Load encrypted text</button>
    </div>
</div>

<script>

    function stringToUint8Array(text) {
        return new TextEncoder().encode(text);
    }

    function bufToString(arr) {
        return new TextDecoder().decode(arr);
    }

    function u_atob(ascii) {
        return Uint8Array.from(atob(ascii), c => c.charCodeAt(0));
    }

    function u_btoa(buffer) {
        var binary = [];
        var bytes = new Uint8Array(buffer);
        for (var i = 0, il = bytes.byteLength; i < il; i++) {
            binary.push(String.fromCharCode(bytes[i]));
        }
        return btoa(binary.join(''));
    }

    function willGenerateKeyPBKDF2(secret) {
        if (!secret) {
            // Firefox doesn't allow it, Chrome does. Let's make it consistent.
            throw new Error('Cannot generate a key with an empty secret');
        }

        return crypto.subtle.importKey(
            'raw',
            stringToUint8Array(secret),
            { name: 'PBKDF2' },
            false, // whether the key can be extracted or not
            [ 'deriveKey' ]
        );
    }

    function willDeriveKey(baseKey, {saltString, iterations}) {
        return crypto.subtle.deriveKey(
            {
                name: 'PBKDF2',
                salt: stringToUint8Array(saltString),
                iterations: iterations,
                hash: 'SHA-256'
            },
            baseKey,
            { "name": 'AES-GCM', "length": 256 },
            false, // whether the key can be extracted or not
            [ "encrypt", "decrypt" ]
        );
    }

    function willEncryptAESGCM(key, params) {
        const { iv, additionalData, plaintext } = params;
        const adAsBytes = stringToUint8Array(JSON.stringify(additionalData));

        return crypto.subtle.encrypt(
            {
                name: 'AES-GCM',
                iv,
                additionalData: adAsBytes,
            },
            key,
            stringToUint8Array(plaintext)
        ).then(enc => {
            return [
                u_btoa(adAsBytes),
                u_btoa(iv),
                u_btoa(enc), // ciphertext | tag
            ].join('.');
        });
    }

    function willDecryptAESGCM(b_key, b_iv, b_ad, b_enc) {
        return crypto.subtle.decrypt(
            {
                name: 'AES-GCM',
                iv: b_iv,
                additionalData: b_ad,
            },
            b_key,
            b_enc
        ).then(dec => ({
            plaintext: bufToString(dec),
            additionalData: JSON.parse(bufToString(b_ad)),
            iv: b_iv,
        }));
    }

    /**
     * Encrypt plaintext using 256 AES in CBC mode, deriving the key with PBKDF2.
     *
     * @param string plaintext the text to encrypt
     * @param string secret the secret to use to derive the key with PBKDF2
     * @param array optionsPBKDF2
     *              - string salt use it to prevent dictionary attacks
     *              - number iterations the number of PBKDF2 iterations to derive the key
     * @param arrayBuffer iv a nonce to use in AES-GCM
     * @return Promise that will resolve to an array with keys iv, ciphertext, whose values are hexstrings
     *
     * >>> // example
     * >>>
     * >>> willEncryptPlaintext(
     * >>>     'the text to encrypt',
     * >>>     'your strong secret',
     * >>>     {
     * >>>         salt: 'string to make your key unique even if your secret was more common than you thinked',
     * >>>         iterations: 60000,
     * >>>     },
     * >>>     new Uint8Array([0,1,...,11]) // 96 bit nonce
     * >>> ).then(function (result) {
     * >>>     console.log(result); // e.g. "<additional data as hex>.<iv as hex>.<ciphertext as hex>"
     * >>> });
     */
    function willEncryptPlaintext(plaintext, secret, optionsPBKDF2, iv) {
        return willGenerateKeyPBKDF2(secret)
        .then(function (baseKey) {
            return willDeriveKey(baseKey, optionsPBKDF2);
        })
        .then(function (derivedKey) {
            return willEncryptAESGCM(derivedKey, {
                iv,
                plaintext,
                additionalData: optionsPBKDF2
            });
        });
    }

    /**
     * Decrypt ciphertext using 256 AES in CBC mode, deriving the key with PBKDF2.
     *
     * @param string ciphertext the text to encrypt
     * @param string secret the secret to use to derive the key with PBKDF2
     * @param array optionsPBKDF2
     *              - string salt the string used alongside the secret to derive the key
     *              - number iterations the number of PBKDF2 iterations used to derive the key
     * @return Promise that will resolve to an object with key plaintext, whose value is the plaintext as string
     */
    function willDecryptCiphertext(encryptedBox, secret) {
        let [b64_ad = '', b64_iv = '', b64_enc = ''] = encryptedBox.split('.');
        let [b_ad, b_iv, b_enc] = [b64_ad, b64_iv, b64_enc].map(u_atob);
        let ad = JSON.parse(bufToString(b_ad));

        let optionsPBKDF2 = {
            salt: ad.salt || '',
            iterations: ad.iterations || '',
        };

        return willGenerateKeyPBKDF2(secret)
        .then(function (baseKey) {
            return willDeriveKey(baseKey, optionsPBKDF2);
        })
        .then(function (derivedKey) {
            return willDecryptAESGCM(derivedKey, b_iv, b_ad, b_enc);
        });
    }

    function willRequestEncryption(plaintext) {
        let secret = getSecret();
        let iv = window.crypto.getRandomValues(new Uint8Array(16));
        let optionsPBKDF2 = {
            salt: getPBKDF2Salt(),
            iterations: getPBKDF2Iterations(),
        };

        return willEncryptPlaintext(plaintext, secret, optionsPBKDF2, iv);
    }

    function willRequestDecryption() {
        let ciphertext = getCiphertext();

        if (!ciphertext) {
            return Promise.resolve({
                plaintext: '',
            });
        }

        let secret = getSecret();
        return willDecryptCiphertext(ciphertext, secret)
        .catch(function(e) {
            setCiphertextErrorMessage('The operation failed (most likely the ciphertext is not correct)');
            setPlaintextErrorMessage(
                'The plaintext does not reflect the ciphertext (focus the textarea to refresh)'
            );

            return Promise.reject(e);
        });
    }

    function triggerDownloadDialog(blob, filename) {
        const url = window.URL.createObjectURL(blob);
        const anchor = getDownloadDialogAnchorDOMElement();

        anchor.href = url;
        anchor.download = filename;
        anchor.click();
        window.URL.revokeObjectURL(url);
    }

    /**
     * Return a string with the format YYYY-MM-DD_HHMMSS
     */
    function makeDateTimePrefix(date) {
        const isoDateTime = date.toISOString();
        const datePart = isoDateTime.split('T')[0];
        const timePart = isoDateTime.split('T')[1].split('.')[0];

        return datePart + '_' + timePart.replace(/:/g, '');
    }

    let getPlaintextDOMElement = () => document.getElementById('plaintext');
    let getPlaintext = () => getPlaintextDOMElement().value;
    let setPlaintext = value => getPlaintextDOMElement().value = value;

    let getCiphertextDOMElement = () => document.getElementById('ciphertext');
    let getCiphertext = () => getCiphertextDOMElement().value;
    let setCiphertext = value => getCiphertextDOMElement().value = value;

    let getSecretDOMElement = () => document.getElementById('secret');
    let getSecret = () => getSecretDOMElement().value;

    let getPBKDF2Salt = () => PBKDF2_SALT;
    let getPBKDF2Iterations = () => PBKDF2_ITERATIONS;
    let getFilename = () => FILENAME;

    let getDownloadCleartextButtonDOMElement = () => document.getElementById('download-cleartext');
    let getDownloadCiphertextButtonDOMElement = () => document.getElementById('download-ciphertext');
    let getDownloadDialogAnchorDOMElement = () => document.getElementById('download-dialog-anchor');

    let getUploadCiphertextButtonDOMElement = () => document.getElementById('upload-ciphertext');
    let getReloadCiphertextButtonDOMElement = () => document.getElementById('reload-ciphertext');

    let getSaltIsMissingDOMElement = () => document.getElementById('salt-is-missing');

    let getUsernameDOMElement = () => document.getElementById('username');
    let getUsername = () => getUsernameDOMElement().value;
    let getConfirmSecretDOMElement = () => document.getElementById('confirm-secret');
    let getConfirmSecret = () => getConfirmSecretDOMElement().value;

    let getCiphertextErrorMessageDOMElement = () => document.getElementById('ciphertext-error-message');
    let getCiphertextErrorMessage = message => getCiphertextErrorMessageDOMElement().innerText.trim();
    let setCiphertextErrorMessage = message => getCiphertextErrorMessageDOMElement().innerText = message;

    let getPlaintextErrorMessageDOMElement = () => document.getElementById('plaintext-error-message');
    let getPlaintextErrorMessage = message => getPlaintextErrorMessageDOMElement().innerText.trim();
    let setPlaintextErrorMessage = message => getPlaintextErrorMessageDOMElement().innerText = message;

    let clearErrorMessages = () => {
        setCiphertextErrorMessage('');
        setPlaintextErrorMessage('');
    };

    let hasErrors = () => Boolean(getPlaintextErrorMessage() || getCiphertextErrorMessage());

    // encrypt on focus only when there are errors, otherwise with a random IV we would
    // change the ciphertext without reason
    getPlaintextDOMElement().addEventListener('focus', ev => {
        if (hasErrors()) {
            clearErrorMessages();
            willRequestEncryption(getPlaintext())
            .then(setCiphertext);
        }
    });

    getDOMElementsWhoseValuesAreUsedToEncrypt = () => document.querySelectorAll('.change-ciphertext');

    // redo encryption if any of the fields used to encrypt has changed
    getDOMElementsWhoseValuesAreUsedToEncrypt().forEach(elem => {
        let eventType = 'input';

        if (elem.type === 'checkbox') {
            eventType = 'change';
        }

        elem.addEventListener(eventType, ev => {
            clearErrorMessages();
            willRequestEncryption(getPlaintext())
            .then(setCiphertext);
        });
    });

    function updatePlaintextFromCiphertext() {
        clearErrorMessages();
        willRequestDecryption()
        .then(function (result) {
            setPlaintext(result.plaintext);
        }).catch(e => {
            console.error('cannot decode ciphertext', e);
        });
    }

    // redo decryption if the ciphertext has changed (or may have changed)
    ['input', 'focus'].forEach(eventType => {
        getCiphertextDOMElement().addEventListener(eventType, ev => updatePlaintextFromCiphertext())
    });

    getDownloadCiphertextButtonDOMElement().addEventListener('click', ev => {
        ev.preventDefault();

        willRequestEncryption(getPlaintext())
        .then(encryptedBox => {
            const blob = new Blob([encryptedBox], {type: "plain/text"});
            const filename = makeDateTimePrefix(new Date()) + '_encrypted_vanillacrypto.txt';

            triggerDownloadDialog(blob, filename);
        });
    });

    getDownloadCleartextButtonDOMElement().addEventListener('click', ev => {
        ev.preventDefault();

        const blob = new Blob([getPlaintext()], {type: "plain/text"});
        const filename = makeDateTimePrefix(new Date()) + '_cleartext_vanillacrypto.txt';

        triggerDownloadDialog(blob, filename);
    });

    getReloadCiphertextButtonDOMElement().addEventListener('click', async function(ev) {
        ev.preventDefault();
        let ciphertext = await willGetFirstFileContent();
        setCiphertext(ciphertext);
        updatePlaintextFromCiphertext();
    });

    async function _willGetAuthToken() {
        let token = null;
        let url = new URL(STORE_URL + '/user/auth/request-challenge');
        url.searchParams.append('username', getUsername());

        let parsedResponse = await fetchJSON(url.href);

        let finalResponse = null;

        if (parsedResponse.status === 401) {
            // user does not exist
            if (!window.confirm('No user found with that username, would you like to create it?')) {
                throw new Error('User refused to create an account');
            }

            if (getConfirmSecret() !== getSecret()) {
                window.alert('The passwords don\'t match');
                throw new Error('password mismatch');
            }

            finalResponse = await willCreateNewUser();
        } else if (parsedResponse.status === 200) {
            // user exists, we've got a challenge to decrypt
            let challenge = parsedResponse.content.challenge
            finalResponse = await willAnswerChallenge(challenge);

        } else {
            throw new Error(JSON.stringify(parsedResponse));
        }

        return finalResponse.content.token;
    }

    /**
     * Retrieve an authorization token.
     *
     * The token is cached unless the option {refresh: true} is provided.
     * Use fetchJSONWithRetryOnAuthExpired() to automatically refresh it.
     */
    let willGetAuthToken = (() => {
        let token = null;

        return async function(options) {
            if (!token || (options || {}).refresh) {
                token = await _willGetAuthToken();
            }
            return token;
        }
    })();

    async function willAnswerChallenge(challenge) {
        let answerBox = await willDecryptCiphertext(challenge, getSecret());
        let answer = answerBox.plaintext;

        let url = new URL(STORE_URL + '/user/auth/answer-challenge');
        return fetchJSONWithRetryOnAuthExpired(url.href, {
            method: 'POST',
            body: JSON.stringify({
                username: getUsername(),
                answer,
            }),
        });
    }

    async function willCreateNewUser() {
        // create a 32 char length random hex string
        let b_answer = window.crypto.getRandomValues(new Uint8Array(16));
        let h_answer = Array.prototype.map.call(b_answer, x => ('00' + x.toString(16)).slice(-2)).join('');

        let url = new URL(STORE_URL + '/user/');
        return fetchJSON(url.href, {
            method: 'POST',
            body: JSON.stringify({
                username: getUsername(),
                challenge: await willRequestEncryption(h_answer),
                answer: h_answer,
            }),
        });
    }

    getUploadCiphertextButtonDOMElement().addEventListener('click', async function(ev) {
        ev.preventDefault();

        let filename = getFilename();

        try {
            let ciphertext = await willRequestEncryption(getPlaintext()); // XXX this way we upload something different from what the user sees !!!!
            let uploadUrl = await willRequestUploadUrl(filename);
            let objectUrl = uploadUrl.replace(/\?.*$/, ''); // XXX this is not safe probably
            await willUploadCiphertext(uploadUrl, ciphertext);
            let uploadedContent = await willDownload(objectUrl);
            if (uploadedContent !== ciphertext) {
                throw new Error('The uploaded file does not match the original file');
            }
            console.log('Cool, the file was uploaded correctly!');
        } catch (e) {
            console.error('An error arised', e);
        }
    });

    async function willRequestUploadUrl(filename) {
        let href = STORE_URL + '/file/request-upload-url';
        let token = await willGetAuthToken();

        return fetchJSONWithRetryOnAuthExpired(href, {
            method: 'POST',
            body: JSON.stringify({
                jwt: token,
                filename: filename,
            }),
        })
        .then(jsonResponse => jsonResponse.links.upload_url.href);
    }

    async function willUploadCiphertext(uploadUrl, ciphertext) {
        let href = uploadUrl;
        return fetch(href, {
            headers: {
                'Cache-Control': 'None',
                'Expect': '100-continue',
                'Content-Encoding': 'utf-8',
                'Content-Type': 'text/plain',
                // XXX ... no md5 in crypto subtle, so we can't rely on it.
                // We'll have to download the file and verify his content later
                // 'Content-MD5': 'application/json',
            },
            method: 'PUT',
            body: ciphertext,
        });
    }

    function willDownload(href) {
        return fetch(href, {
            mode: 'cors',
            cache: 'no-store',
            referrerPolicy: 'no-referrer',
        })
        .then(response => {
            if (response.ok) {
                return response.text();
            } else {
                return Promise.reject(response.statusText);
            }
        });
    }

    async function willGetFilesList() {
        let url = new URL(STORE_URL + '/files/')
        url.searchParams.append('jwt', await willGetAuthToken());

        let jsonResponse = await fetchJSONWithRetryOnAuthExpired(url.href);
        return jsonResponse.content;
    }

    async function willGetFirstFileContent() {
        let files = await willGetFilesList();
        return files.length > 0 ? await willDownload(files[0].links.read.href) : '';
    }

    async function fetchJSONWithRetryOnAuthExpired(href, options) {
        let response = await fetchJSON(href, options);
        if (response.error && response.error.code === 1007) {
            // 1007 means "token expired"
            await willGetAuthToken({refresh: true});
            response = await fetchJSON(href, options);
        }
        return response;
    }

    async function fetchJSON(href, options) {
        options = Object.assign({}, {
            headers: {},
            mode: 'cors',
            cache: 'no-store',
            referrerPolicy: 'no-referrer',
        }, options || {});

        options.headers['Content-Type'] = 'application/json';

        let response = await fetch(href, options);

        if (response.headers.get('Content-Type') === 'application/json') {
            return response.json();
        } else {
            throw new Error(response.statusText);
        }
    }

    if (!getPBKDF2Salt()) {
        getSaltIsMissingDOMElement().style.display = 'block';
    }

</script>
</body>
</html>